---
title: ë°°ê²½ ì§€ì‹ & ì‹œì‘í•˜ê¸°
actions: ["checkAnswer", "hints"]
requireLogin: true
material:
  editor:
    language: sol
    startingCode:
      "ZombieToken.sol": |
        // ì—¬ê¸°ì„œ ì‹œì‘í•˜ê²Œ

      "ERC721XToken.sol": |

        // Full implementation with all included files at https://github.com/loomnetwork/erc721x

        pragma solidity ^0.4.25;

        import "./../../Interfaces/ERC721X.sol";

        import "./../../Interfaces/ERC721XReceiver.sol";
        import "./ERC721XTokenNFT.sol";

        import "openzeppelin-solidity/contracts/AddressUtils.sol";
        import "./../../Libraries/ObjectsLib.sol";


        // Additional features over NFT token that is compatible with batch transfers
        contract ERC721XToken is ERC721X, ERC721XTokenNFT {

            using ObjectLib for ObjectLib.Operations;
            using AddressUtils for address;

            bytes4 internal constant ERC721X_RECEIVED = 0x660b3370;
            bytes4 internal constant ERC721X_BATCH_RECEIVE_SIG = 0xe9e5be6a;

            event BatchTransfer(address from, address to, uint256[] tokenTypes, uint256[] amounts);


            modifier isOperatorOrOwner(address _from) {
                require((msg.sender == _from) || operators[_from][msg.sender], "msg.sender is neither _from nor operator");
                _;
            }

            function implementsERC721X() public pure returns (bool) {
                return true;
            }

            /**
             * @dev transfer objects from different tokenIds to specified address
             * @param _from The address to BatchTransfer objects from.
             * @param _to The address to batchTransfer objects to.
             * @param _tokenIds Array of tokenIds to update balance of
             * @param _amounts Array of amount of object per type to be transferred.
             * Note:  Arrays should be sorted so that all tokenIds in a same bin are adjacent (more efficient).
             */
            function _batchTransferFrom(address _from, address _to, uint256[] _tokenIds, uint256[] _amounts)
                internal
                isOperatorOrOwner(_from)
            {

                // Requirements
                require(_tokenIds.length == _amounts.length, "Inconsistent array length between args");
                require(_to != address(0), "Invalid recipient");

                if (tokenType[_tokenIds[0]] == NFT) {
                    tokenOwner[_tokenIds[0]] = _to;
                    emit Transfer(_from, _to, _tokenIds[0]);
                }

                // Load first bin and index where the object balance exists
                (uint256 bin, uint256 index) = ObjectLib.getTokenBinIndex(_tokenIds[0]);

                // Balance for current bin in memory (initialized with first transfer)
                // Written with bad library syntax instead of as below to bypass stack limit error
                uint256 balFrom = ObjectLib.updateTokenBalance(
                    packedTokenBalance[_from][bin], index, _amounts[0], ObjectLib.Operations.SUB
                );
                uint256 balTo = ObjectLib.updateTokenBalance(
                    packedTokenBalance[_to][bin], index, _amounts[0], ObjectLib.Operations.ADD
                );

                // Number of transfers to execute
                uint256 nTransfer = _tokenIds.length;

                // Last bin updated
                uint256 lastBin = bin;

                for (uint256 i = 1; i < nTransfer; i++) {
                    // If we're transferring an NFT we additionally should update the tokenOwner and emit the corresponding event
                    if (tokenType[_tokenIds[i]] == NFT) {
                        tokenOwner[_tokenIds[i]] = _to;
                        emit Transfer(_from, _to, _tokenIds[i]);
                    }
                    (bin, index) = _tokenIds[i].getTokenBinIndex();

                    // If new bin
                    if (bin != lastBin) {
                        // Update storage balance of previous bin
                        packedTokenBalance[_from][lastBin] = balFrom;
                        packedTokenBalance[_to][lastBin] = balTo;

                        // Load current bin balance in memory
                        balFrom = packedTokenBalance[_from][bin];
                        balTo = packedTokenBalance[_to][bin];

                        // Bin will be the most recent bin
                        lastBin = bin;
                    }

                    // Update memory balance
                    balFrom = balFrom.updateTokenBalance(index, _amounts[i], ObjectLib.Operations.SUB);
                    balTo = balTo.updateTokenBalance(index, _amounts[i], ObjectLib.Operations.ADD);
                }

                // Update storage of the last bin visited
                packedTokenBalance[_from][bin] = balFrom;
                packedTokenBalance[_to][bin] = balTo;

                // Emit batchTransfer event
                emit BatchTransfer(_from, _to, _tokenIds, _amounts);
            }

            function batchTransferFrom(address _from, address _to, uint256[] _tokenIds, uint256[] _amounts) public {
                // Batch Transfering
                _batchTransferFrom(_from, _to, _tokenIds, _amounts);
            }

            /**
             * @dev transfer objects from different tokenIds to specified address
             * @param _from The address to BatchTransfer objects from.
             * @param _to The address to batchTransfer objects to.
             * @param _tokenIds Array of tokenIds to update balance of
             * @param _amounts Array of amount of object per type to be transferred.
             * @param _data Data to pass to onERC721XReceived() function if recipient is contract
             * Note:  Arrays should be sorted so that all tokenIds in a same bin are adjacent (more efficient).
             */
            function safeBatchTransferFrom(
                address _from,
                address _to,
                uint256[] _tokenIds,
                uint256[] _amounts,
                bytes _data
            )
                public
            {

                // Batch Transfering
                _batchTransferFrom(_from, _to, _tokenIds, _amounts);

                // Pass data if recipient is contract
                if (_to.isContract()) {
                    bytes4 retval = ERC721XReceiver(_to).onERC721XBatchReceived(
                        msg.sender, _from, _tokenIds, _amounts, _data
                    );
                    require(retval == ERC721X_BATCH_RECEIVE_SIG);
                }
            }

            function transfer(address _to, uint256 _tokenId, uint256 _amount) public {
                _transferFrom(msg.sender, _to, _tokenId, _amount);
            }

            function transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public {
                _transferFrom(_from, _to, _tokenId, _amount);
            }

            function _transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount)
                internal
                isOperatorOrOwner(_from)
            {
                require(tokenType[_tokenId] == FT);
                require(_amount <= balanceOf(_from, _tokenId), "Quantity greater than from balance");
                require(_to != address(0), "Invalid to address");

                _updateTokenBalance(_from, _tokenId, _amount, ObjectLib.Operations.SUB);
                _updateTokenBalance(_to, _tokenId, _amount, ObjectLib.Operations.ADD);
                emit TransferWithQuantity(_from, _to, _tokenId, _amount);
            }

            function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public {
                safeTransferFrom(_from, _to, _tokenId, _amount, "");
            }

            function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount, bytes _data) public {
                _transferFrom(_from, _to, _tokenId, _amount);
                require(
                    checkAndCallSafeTransfer(_from, _to, _tokenId, _amount, _data),
                    "Sent to a contract which is not an ERC721X receiver"
                );
            }

            function _mint(uint256 _tokenId, address _to, uint256 _supply) internal {
                // If the token doesn't exist, add it to the tokens array
                if (!exists(_tokenId)) {
                    tokenType[_tokenId] = FT;
                    allTokens.push(_tokenId);
                } else {
                    // if the token exists, it must be a FT
                    require(tokenType[_tokenId] == FT, "Not a FT");
                }

                _updateTokenBalance(_to, _tokenId, _supply, ObjectLib.Operations.ADD);
                emit TransferWithQuantity(address(this), _to, _tokenId, _supply);
            }


            function checkAndCallSafeTransfer(
                address _from,
                address _to,
                uint256 _tokenId,
                uint256 _amount,
                bytes _data
            )
                internal
                returns (bool)
            {
                if (!_to.isContract()) {
                    return true;
                }

                bytes4 retval = ERC721XReceiver(_to).onERC721XReceived(
                    msg.sender, _from, _tokenId, _amount, _data);
                return(retval == ERC721X_RECEIVED);
            }

        }
    answer: >
      pragma solidity ^0.4.25;

      import "./ERC721XToken.sol";

      contract ZombieCard is ERC721XToken {

      }
---

ì´ ë ˆìŠ¨ì—ì„œëŠ” ì˜ˆì œ ë¸”ë¡ì²´ì¸ ê²Œì„ì„ ìœ„í•œ í† í° ì»¨íŠ¸ë™íŠ¸ë¥¼ ë§Œë“¤ì–´ê°ˆ ê²ƒì´ë„¤.

ì´ ì»¨íŠ¸ë™íŠ¸ëŠ” ìš°ë¦¬ Loom Networkì—ì„œ ë§Œë“  ê²Œì„ì¸
<a href="https://loom.games/" target=_blank>ì¢€ë¹„ ë°°í‹€ê·¸ë¼ìš´ë“œ</a>ì—ì„œ ERC721xë¥¼
êµ¬í˜„í•œ ë°©ì‹ì„ ê¸°ë°˜ìœ¼ë¡œ í•˜ë„¤ - ì¢€ë¹„ ë°°í‹€ê·¸ë¼ìš´ë“œëŠ” ë§¤ì§:ë” ê°œë”ë§ì´ë‚˜ í•˜ìŠ¤ìŠ¤í†¤ê³¼
ë¹„ìŠ·í•œ ë¸”ë¡ì²´ì¸ ê¸°ë°˜ì˜ ì¹´ë“œ ìˆ˜ì§‘í˜• ì¹´ë“œ ê²Œì„ì´ì§€.

ì´ë ‡ê²Œ í•´ì„œ ìë„¤ëŠ” ì‹¤ì œ ì„¸ìƒì—ì„œ ì“°ì´ëŠ” ì˜ˆì‹œë“¤ì´ ì–´ë–»ê²Œ ìƒê²¼ëŠ”ì§€ ì•Œ ìˆ˜ ìˆì„ ê²ƒì´
ê³ , ì´ ë ˆìŠ¨ì„ ì™„ë£Œí•˜ê³  ë‚˜ë©´ ìë„¤ë§Œì˜ ê²Œì„ì— ì´ êµ¬í˜„ì„ ì ìš©í•  ì¤€ë¹„ê°€ ëë‚  ê²ƒì´ë„¤.

ì²« ë²ˆì§¸ ì±•í„°ì—ì„œëŠ”, ì•ìœ¼ë¡œ ë‚˜ì˜¬ ë‚´ìš©ë“¤ì„ ì˜ ì´í•´í•  ìˆ˜ ìˆë„ë¡ ê¸°ë°˜ ì§€ì‹ì„ ë¨¼ì € í™•
ì¸í•´ë³´ë„ë¡ í•˜ì§€...

## ë°°ê²½ ì§€ì‹: ê·¸ë˜ì„œ í† í°ì´ ë­ì•¼?

ê²Œì„ ë‚´ ì•„ì´í…œë“¤ì„ "í† í°"ì´ë¼ ë§í•˜ëŠ” ê²ƒì´ ì¡°ê¸ˆ í—·ê°ˆë¦´ ìˆ˜ë„ ìˆë„¤. "í† í°"ì€ í™”íì²˜
ëŸ¼ ì“°ì´ëŠ” ë¬´ì–¸ê°€ë¥¼ ì•”ì‹œí•˜ê¸° ë•Œë¬¸ì´ì§€.

í•˜ì§€ë§Œ ì´ë”ë¦¬ì›€ì—ì„œ **_í† í°_**ì´ë¼ëŠ” ë‹¨ì–´ëŠ” ê·¸ì € ë˜‘ê°™ì€ ê³µí†µ í•¨ìˆ˜ë“¤ì„ êµ¬í˜„í•˜ë„ë¡
í•˜ëŠ” ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì˜ í‘œì¤€ì„ ì˜ë¯¸í•  ë¿ì´ë„¤.
`transfer(address _to, uint256 _value)`ì´ë‚˜ `balanceOf(address _owner)` ê°™ì€ í•¨
ìˆ˜ë“¤ ë§ì´ì§€.

ê·¸ë˜, ìë„¤ëŠ” í™”íë¥¼ ì „ì†¡í•˜ê±°ë‚˜ í™”íì˜ ì”ì•¡ì„ ê°€ì§€ê³  ìˆì„ ìˆ˜ ìˆë„¤ - í•˜ì§€ë§Œ ì–´ë–¤
ê²Œì„ì—ì„œ ì•„ì´í…œì„ ì „ì†¡í•˜ê±°ë‚˜ ì•„ì´í…œ ì¸ë²¤í† ë¦¬ë¥¼ ê°€ì§ˆ ìˆ˜ë„ ìˆì§€. ê²€ì´ë‚˜ ì¹´ë“œ ì•„ì´
í…œ ê°™ì€ ê²ƒë“¤ ë§ì´ë„¤.

ê²Œì„ ë‚´ì—ì„œ ê²€ì´ í™”íì²˜ëŸ¼ ì†Œëª¨í•  ìˆ˜ ìˆëŠ” ê²ƒì´ ì•„ë‹ˆë¼ í•´ë„ - í”Œë ˆì´ì–´ê°€ ì†Œìœ í•  ìˆ˜
ìˆëŠ” ê²ƒì´ë¼ë©´ ì–´ë–¤ ê²ƒì´ë“  ì´ëŸ° ë˜‘ê°™ì€ ê¸°ë³¸ ê¸°ëŠ¥ë“¤ì´ _ì •ë§ë¡œ_ í•„ìš”í•˜ë„¤.

ê·¸ëŸ¬ë‹ˆ "í† í°"ì˜ ê°œë…ì€ ê³µí†µ ë©”ì†Œë“œë“¤ì„ ì¶”ìƒí™”í•˜ì—¬ ìš°ë¦¬ì˜ ê²Œì„ì— ë„£ì„ ëª¨ë“  ì•„ì´í…œ
ë“¤ì— ì ìš©í•˜ê¸°ì— ì ì ˆí•˜ë„¤ - ì´ëŸ° ë°©ì‹ìœ¼ë¡œ ì´ë”ë¦¬ì›€ìƒì˜ ëª¨ë“  ê²Œì„ ì•„ì´í…œë“¤ì´ ê³µí†µ
ì¸í„°í˜ì´ìŠ¤ë¥¼ ê³µìœ í•˜ê³ , ë™ì¼í•œ í† í° í‘œì¤€ì„ ë”°ë¥´ëŠ” ì–´ë–¤ ì§€ê°‘ì´ë‚˜ ë§ˆì¼“í”Œë ˆì´ìŠ¤ì—ë„
ì“°ì¼ ìˆ˜ ìˆëŠ” ê²ƒì´ì§€.

## ë‹¤ë¥¸ í† í° í‘œì¤€ë“¤: ERC20ê³¼ ERC721

ê°€ì¥ ë„ë¦¬ ì•Œë ¤ì§„ í† í° í‘œì¤€ì€ **_ERC20 í† í°_**ì´ë„¤. ì´ í† í°ë“¤ì€ í™”íì²˜ëŸ¼ ì“°ì´ì§€.
í•˜ì§€ë§Œ ì´ë“¤ì€ ë””ì§€í„¸ ì•„ì´í…œë“¤ì„ í‘œí˜„í•˜ëŠ” ë°ì—ëŠ” ë”± ì í•©í•˜ì§€ëŠ” ì•Šë„¤. íŠ¸ë ˆì´ë”© ì¹´
ë“œ ê²Œì„ì—ì„œì˜ ì¹´ë“œ ê°™ì€ ê²ƒë“¤ ë§ì´ì§€.

ì²«ì§¸ë¡œ, ì¹´ë“œë“¤ì€ í™”íì²˜ëŸ¼ ë¶„í• ì´ ë˜ì§€ ì•Šë„¤ - í•œ ì¹´ë“œì˜ 2/5ë¥¼ ì†Œìœ í•œë‹¤ê±°ë‚˜ í•  ìˆœ
ì—†ì§€.

ë‘˜ì¨°ë¡œ, ëª¨ë“  ì¹´ë“œê°€ ë˜‘ê°™ì´ ë§Œë“¤ì–´ì§€ì§€ ì•Šê¸°ì—, ìƒí˜¸ êµí™˜í•  ìˆ˜ ì—†ë„¤. ìë„¤ì˜
**Z-Virus** ì¹´ë“œë¥¼ ë‚´ **Ozmoziz** ì¹´ë“œì™€ êµí™˜í•˜ê³  ì‹¶ì§€ëŠ” ì•Šê² ì§€.

ê·¸ë˜ì„œ í¬ë¦½í†  ìˆ˜ì§‘í’ˆë“¤ì— ë” ì˜ ë§ëŠ” ë‹¤ë¥¸ í† í° í‘œì¤€ì´ ìˆë„¤. ì´ í‘œì¤€ì€
**_ERC721_**ì´ë¼ ë¶ˆë¦¬ì§€.

**_ERC721 í† í°ë“¤ì€_** ìƒí˜¸ êµí™˜ì´ ë˜ì§€ **ì•Šë„¤**. ê° ì•„ì´í…œì€ ê³ ìœ í•˜ê²Œ ë‹¤ë¤„ì§€ê³ ,
ê³ ìœ  ID ê°’ì„ ê°€ì§€ë„¤. ë˜ ë‚˜ëˆ ì§€ì§€ë„ ì•Šì§€ - ì´ í† í°ë“¤ì€ í•˜ë‚˜ì˜ ì „ì²´ ë‹¨ìœ„ë¡œë§Œ ê±°ë˜
ë¥¼ í•  ìˆ˜ ìˆë„¤.

ê·¸ëŸ¬ë‹ˆ ì´ê²ƒì´ ìš°ë¦¬ì˜ íŠ¸ë ˆì´ë”© ì¹´ë“œ ê²Œì„ì„ ë§Œë“¤ ë•Œ ë” ì˜ ë§ê² ì§€.

ìë„¤, ë‚´ê°€ **ë” ì˜** ë§ëŠ”ë‹¤ê³  í•œ ê±° ì•Œì•„ì°¨ë ¸ë‚˜? ì™„ë²½í•˜ë‹¤ëŠ” ê±´ ì•„ë‹ˆì•¼, ê·¸ë ‡ì§€? ğŸ˜‰

## ERC721x - ë‘ ì„¸ê³„ì˜ ì¥ì ë§Œì„ ì‚¬ìš©í•˜ê¸°

ê²Œì„ ë‚´ ì•„ì´í…œì— ëŒ€í•´ ERC721ì´ ê°€ì§€ëŠ” ë¬¸ì œëŠ”, ëŒ€ë¶€ë¶„ì˜ ê²Œì„ë“¤ì—ì„œëŠ” **ì‹¤ì œë¡œ**
ë™ì¼í•œ ì•„ì´í…œë“¤ì´ ê½¤ ìˆë‹¤ëŠ” ê²ƒì´ë„¤.

ì˜ˆë¥¼ ë“¤ì–´, ìš°ë¦¬ì˜ ì¹´ë“œ ê²Œì„ì— ì„œë¡œ ë‹¤ë¥¸ 300ê°€ì§€ ì¢…ë¥˜ì˜ ì¹´ë“œë“¤ì´ ìˆë‹¤ê³  í•´ë³´ì§€.
í•˜ì§€ë§Œ ì´ ì¹´ë“œë“¤ì€ ê°ê° í•˜ë‚˜ ì´ìƒì˜ ë³µì‚¬ë³¸ì´ ìˆì–´ì•¼ í•  ê²ƒì´ë„¤ - ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ë§
ì€ ì‚¬ëŒë“¤ì´ ìš°ë¦¬ ê²Œì„ì„ í”Œë ˆì´í•  ìˆ˜ëŠ” ì—†ê² ì§€!

ë™ì¼í•œ ì¹´ë“œì˜ ë‹¤ì¤‘ ë³µì‚¬ë³¸ì€ (ëŒ€ë¶€ë¶„) ìƒí˜¸ êµí™˜ì´ ë˜ë„¤. ê·¸ëŸ¬ë‹ˆ ì´ë¥¼ ê³ ë ¤í•œ ìƒˆë¡œìš´
í† í° í‘œì¤€ì„ ë§Œë“¤ í•„ìš”ê°€ ìˆê² ì§€.

ERC721xëŠ” ë‹¤ì–‘í•œ í† í°ë“¤ì„ ì •ì˜í•  ìˆ˜ ìˆê²Œ í•˜ê³ (ì¹´ë“œ í…œí”Œë¦¿ ê°™ì€ ê²ƒì„ ìƒê°í•´ë³´ê²Œ),
ê° ì¹´ë“œë§ˆë‹¤ í•´ë‹¹ ì¹´ë“œì˜ ì „ì²´ ê°œìˆ˜ ë“±ì„ ì •ì˜í•  ìˆ˜ ìˆê²Œ í•˜ì—¬ ì´ëŸ¬í•œ ì‚¬ìš© ì‚¬ë¡€ë¥¼ ì²˜
ë¦¬í•˜ê³  ìˆë„¤.

ì–´ë–»ê²Œ í•˜ê³  ìˆëŠ”ì§€ëŠ” ìë„¤ë„ ë³´ê²Œ ë  ê²ƒì´ë„¤. ìš°ë¦¬ê°€ ë‹¤ìŒ ì±•í„°ë“¤ì—ì„œ ìë„¤ì—ê²Œ í•˜ë‚˜
í•˜ë‚˜ ì„¤ëª…í•´ì¤„ ê²ƒì´ë‹ˆ ë§ì´ë„¤. ğŸ‘¨â€ğŸ«

## ì‹œì‘í•˜ê¸°: í”„ë¡œì íŠ¸ì—ì„œ ERC721x ì‚¬ìš©í•˜ê¸°

ìƒˆë¡œìš´ ERC721x í† í°ì„ ë§Œë“¤ ë•Œ, ë°”ë‹¥ë¶€í„° ì‹œì‘í•  í•„ìš”ëŠ” ì—†ë„¤. ERC20 í† í°ì„ ë§Œë“¤ ë•Œ
<a href="https://github.com/OpenZeppelin/openzeppelin-solidity" target=_blank>Open
Zeppelin</a> ê°™ì€ ê³³ì—ì„œ í…œí”Œë¦¿ì„ ë³µì‚¬í•˜ê³  í•„ìš”í•œ ë³€ê²½ì„ í•˜ë©´ì„œ ë§Œë“¤ê¸° ì‹œì‘í•˜ëŠ”
ê²ƒì²˜ëŸ¼, ERC721xë„ ìë„¤ í”„ë¡œì íŠ¸ì— ìš°ë¦¬ì˜ êµ¬í˜„ì„ í¬í•¨í•˜ë©´ì„œ ë§Œë“¤ê¸° ì‹œì‘í•  ìˆ˜ ìˆë„¤
.

í–¥í›„ í”„ë¡œì íŠ¸ì— ì´ë¥¼ í¬í•¨í•˜ë ¤ë©´,
<a href="https://github.com/loomnetwork/erc721x" target=_blank>ì—¬ê¸°</a> ìš°ë¦¬
Githubì— ìˆëŠ” ì„¤ëª…ëŒ€ë¡œ ë”°ë¼í•˜ë©´ ë˜ë„¤. í•˜ì§€ë§Œ ì´ë²ˆ ë ˆìŠ¨ì—ì„œëŠ”, ìš°ë¦¬ê°€ ë¨¼ì € ìë„¤
í”„ë¡œì íŠ¸ì— `ERC721XToken.sol`ë¥¼ ë„£ì–´ë†“ì•˜ë„¤.

ëª¨ë“  ì½”ë“œë¥¼ ì´í•´í•˜ëŠ” ê²ƒì— ëŒ€í•´ì„œëŠ” ê±±ì •í•  í•„ìš” ì—†ë„¤ - ìë„¤ê°€ ì´í•´í•  í•„ìš”ê°€ ìˆëŠ”
ë¶€ë¶„ë“¤ì— ëŒ€í•´ì„œëŠ” ìš°ë¦¬ê°€ í•˜ë‚˜í•˜ë‚˜ ì„¤ëª…í•´ì¤„ ê²ƒì´ë‹ˆ ë§ì´ë„¤.

# ì§ì ‘ í•´ë³´ê¸°

ê¸°ì´ˆë¶€í„° ì‹œì‘í•˜ë„ë¡ í•˜ì§€: "ZombieCard"ë¼ëŠ” ì´ë¦„ìœ¼ë¡œ `ERC721XToken`ì˜ ë¡œì§ì„ ìƒì†
ë°›ëŠ” ìƒˆë¡œìš´ ì»¨íŠ¸ë™íŠ¸ë¥¼ ë§Œë“¤ ê²ƒì´ë„¤.

1. ë¨¼ì €, ë§¨ ìœ„ì— ìš°ë¦¬ê°€ `pragma solidity ^0.4.25`ë¥¼ ì‚¬ìš©í•œë‹¤ê³  ì„ ì–¸í•˜ê²Œ.

2. pragmaë¥¼ ì„ ì–¸í•œ í›„ì—, ë‹¤ìŒ íŒŒì¼ì„ `import`í•˜ê²Œ: `./ERC721XToken.sol`

3. ë‹¤ìŒìœ¼ë¡œ, ìƒˆë¡œìš´ `contract`ë¥¼ "ZombieCard"ë¼ëŠ” ì´ë¦„ìœ¼ë¡œ ì„ ì–¸í•˜ê²Œ. ì´ ì»¨íŠ¸ë™íŠ¸
   ëŠ” `is` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•´ì„œ `ERC721XToken`ì„ ìƒì†í•´ì•¼ í•˜ë„¤. ì§€ê¸ˆì€ ì»¨íŠ¸ë™íŠ¸ì˜
   ë‚´ìš©ì€ ë¹„ì›Œë‘ê²Œ.

> ì°¸ê³ : ê¸°ì´ˆ ë‚´ìš©ë“¤ì´ ì˜ ê¸°ì–µì´ ë‚˜ì§€ ì•Šì•„ í—·ê°ˆë¦°ë‹¤ë©´,
> <a href="https://cryptozombies.io/en/lesson/1/chapter/2">ë ˆìŠ¨1 ì±•í„°2</a>ì™€
> <a href="https://cryptozombies.io/en/lesson/2/chapter/5">ë ˆìŠ¨2 ì±•í„°5</a>ë¥¼ ë³µ
> ìŠµí•˜ë„ë¡ í•˜ê²Œ.
