---
title: FTë¥¼ NFTë¡œ ë³€í™˜í•˜ê¸° (ì´ì–´ì„œ)
actions: ["checkAnswer", "hints"]
requireLogin: true
material:
  editor:
    language: sol
    startingCode:
      "ZombieCard.sol": |
        pragma solidity ^0.4.25;

        import "./ERC721XToken.sol";
        import "./Ownable.sol";

        contract ZombieCard is ERC721XToken {

            mapping(uint => uint) internal tokenIdToIndividualSupply;
            mapping(uint => uint) internal nftTokenIdToMouldId;
            uint nftTokenIdIndex = 1000000;


            event TokenAwarded(uint indexed tokenId, address claimer, uint amount);

            function name() external view returns (string) {
                return "ZombieCard";
            }

            function symbol() external view returns (string) {
                return "ZCX";
            }

            function individualSupply(uint _tokenId) public view returns (uint) {
                return tokenIdToIndividualSupply[_tokenId];
            }

            function mintToken(uint _tokenId, uint _supply) public onlyOwner {
                require(!exists(_tokenId), "Error: Tried to mint duplicate token id");
                _mint(_tokenId, msg.sender, _supply);
                tokenIdToIndividualSupply[_tokenId] = _supply;
            }

            function awardToken(uint _tokenId, address _to, uint _amount) public onlyOwner {
                require(exists(_tokenId), "TokenID has not been minted");
                if (individualSupply(_tokenId) > 0) {
                    require(_amount <= balanceOf(msg.sender, _tokenId), "Quantity greater than from balance");
                    _updateTokenBalance(msg.sender, _tokenId, _amount, ObjectLib.Operations.SUB);
                }
                _updateTokenBalance(_to, _tokenId, _amount, ObjectLib.Operations.ADD);
                emit TokenAwarded(_tokenId, _to, _amount);
            }

            function convertToNFT(uint _tokenId, uint _amount) public {
                require(tokenType[_tokenId] == FT);
                require(_amount <= balanceOf(msg.sender, _tokenId), "You do not own enough tokens");
                // ì—¬ê¸°ì„œ ì‹œì‘í•˜ê²Œ.
            }

        }
      "ERC721XToken.sol": |

        // Full implementation with all included files at https://github.com/loomnetwork/erc721x

        pragma solidity ^0.4.25;

        import "./../../Interfaces/ERC721X.sol";

        import "./../../Interfaces/ERC721XReceiver.sol";
        import "./ERC721XTokenNFT.sol";

        import "openzeppelin-solidity/contracts/AddressUtils.sol";
        import "./../../Libraries/ObjectsLib.sol";


        // Additional features over NFT token that is compatible with batch transfers
        contract ERC721XToken is ERC721X, ERC721XTokenNFT {

            using ObjectLib for ObjectLib.Operations;
            using AddressUtils for address;

            bytes4 internal constant ERC721X_RECEIVED = 0x660b3370;
            bytes4 internal constant ERC721X_BATCH_RECEIVE_SIG = 0xe9e5be6a;

            event BatchTransfer(address from, address to, uint256[] tokenTypes, uint256[] amounts);


            modifier isOperatorOrOwner(address _from) {
                require((msg.sender == _from) || operators[_from][msg.sender], "msg.sender is neither _from nor operator");
                _;
            }

            function implementsERC721X() public pure returns (bool) {
                return true;
            }

            /**
             * @dev transfer objects from different tokenIds to specified address
             * @param _from The address to BatchTransfer objects from.
             * @param _to The address to batchTransfer objects to.
             * @param _tokenIds Array of tokenIds to update balance of
             * @param _amounts Array of amount of object per type to be transferred.
             * Note:  Arrays should be sorted so that all tokenIds in a same bin are adjacent (more efficient).
             */
            function _batchTransferFrom(address _from, address _to, uint256[] _tokenIds, uint256[] _amounts)
                internal
                isOperatorOrOwner(_from)
            {

                // Requirements
                require(_tokenIds.length == _amounts.length, "Inconsistent array length between args");
                require(_to != address(0), "Invalid recipient");

                if (tokenType[_tokenIds[0]] == NFT) {
                    tokenOwner[_tokenIds[0]] = _to;
                    emit Transfer(_from, _to, _tokenIds[0]);
                }

                // Load first bin and index where the object balance exists
                (uint256 bin, uint256 index) = ObjectLib.getTokenBinIndex(_tokenIds[0]);

                // Balance for current bin in memory (initialized with first transfer)
                // Written with bad library syntax instead of as below to bypass stack limit error
                uint256 balFrom = ObjectLib.updateTokenBalance(
                    packedTokenBalance[_from][bin], index, _amounts[0], ObjectLib.Operations.SUB
                );
                uint256 balTo = ObjectLib.updateTokenBalance(
                    packedTokenBalance[_to][bin], index, _amounts[0], ObjectLib.Operations.ADD
                );

                // Number of transfers to execute
                uint256 nTransfer = _tokenIds.length;

                // Last bin updated
                uint256 lastBin = bin;

                for (uint256 i = 1; i < nTransfer; i++) {
                    // If we're transferring an NFT we additionally should update the tokenOwner and emit the corresponding event
                    if (tokenType[_tokenIds[i]] == NFT) {
                        tokenOwner[_tokenIds[i]] = _to;
                        emit Transfer(_from, _to, _tokenIds[i]);
                    }
                    (bin, index) = _tokenIds[i].getTokenBinIndex();

                    // If new bin
                    if (bin != lastBin) {
                        // Update storage balance of previous bin
                        packedTokenBalance[_from][lastBin] = balFrom;
                        packedTokenBalance[_to][lastBin] = balTo;

                        // Load current bin balance in memory
                        balFrom = packedTokenBalance[_from][bin];
                        balTo = packedTokenBalance[_to][bin];

                        // Bin will be the most recent bin
                        lastBin = bin;
                    }

                    // Update memory balance
                    balFrom = balFrom.updateTokenBalance(index, _amounts[i], ObjectLib.Operations.SUB);
                    balTo = balTo.updateTokenBalance(index, _amounts[i], ObjectLib.Operations.ADD);
                }

                // Update storage of the last bin visited
                packedTokenBalance[_from][bin] = balFrom;
                packedTokenBalance[_to][bin] = balTo;

                // Emit batchTransfer event
                emit BatchTransfer(_from, _to, _tokenIds, _amounts);
            }

            function batchTransferFrom(address _from, address _to, uint256[] _tokenIds, uint256[] _amounts) public {
                // Batch Transfering
                _batchTransferFrom(_from, _to, _tokenIds, _amounts);
            }

            /**
             * @dev transfer objects from different tokenIds to specified address
             * @param _from The address to BatchTransfer objects from.
             * @param _to The address to batchTransfer objects to.
             * @param _tokenIds Array of tokenIds to update balance of
             * @param _amounts Array of amount of object per type to be transferred.
             * @param _data Data to pass to onERC721XReceived() function if recipient is contract
             * Note:  Arrays should be sorted so that all tokenIds in a same bin are adjacent (more efficient).
             */
            function safeBatchTransferFrom(
                address _from,
                address _to,
                uint256[] _tokenIds,
                uint256[] _amounts,
                bytes _data
            )
                public
            {

                // Batch Transfering
                _batchTransferFrom(_from, _to, _tokenIds, _amounts);

                // Pass data if recipient is contract
                if (_to.isContract()) {
                    bytes4 retval = ERC721XReceiver(_to).onERC721XBatchReceived(
                        msg.sender, _from, _tokenIds, _amounts, _data
                    );
                    require(retval == ERC721X_BATCH_RECEIVE_SIG);
                }
            }

            function transfer(address _to, uint256 _tokenId, uint256 _amount) public {
                _transferFrom(msg.sender, _to, _tokenId, _amount);
            }

            function transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public {
                _transferFrom(_from, _to, _tokenId, _amount);
            }

            function _transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount)
                internal
                isOperatorOrOwner(_from)
            {
                require(tokenType[_tokenId] == FT);
                require(_amount <= balanceOf(_from, _tokenId), "Quantity greater than from balance");
                require(_to != address(0), "Invalid to address");

                _updateTokenBalance(_from, _tokenId, _amount, ObjectLib.Operations.SUB);
                _updateTokenBalance(_to, _tokenId, _amount, ObjectLib.Operations.ADD);
                emit TransferWithQuantity(_from, _to, _tokenId, _amount);
            }

            function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public {
                safeTransferFrom(_from, _to, _tokenId, _amount, "");
            }

            function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount, bytes _data) public {
                _transferFrom(_from, _to, _tokenId, _amount);
                require(
                    checkAndCallSafeTransfer(_from, _to, _tokenId, _amount, _data),
                    "Sent to a contract which is not an ERC721X receiver"
                );
            }

            function _mint(uint256 _tokenId, address _to, uint256 _supply) internal {
                // If the token doesn't exist, add it to the tokens array
                if (!exists(_tokenId)) {
                    tokenType[_tokenId] = FT;
                    allTokens.push(_tokenId);
                } else {
                    // if the token exists, it must be a FT
                    require(tokenType[_tokenId] == FT, "Not a FT");
                }

                _updateTokenBalance(_to, _tokenId, _supply, ObjectLib.Operations.ADD);
                emit TransferWithQuantity(address(this), _to, _tokenId, _supply);
            }


            function checkAndCallSafeTransfer(
                address _from,
                address _to,
                uint256 _tokenId,
                uint256 _amount,
                bytes _data
            )
                internal
                returns (bool)
            {
                if (!_to.isContract()) {
                    return true;
                }

                bytes4 retval = ERC721XReceiver(_to).onERC721XReceived(
                    msg.sender, _from, _tokenId, _amount, _data);
                return(retval == ERC721X_RECEIVED);
            }

        }
    answer: >
      pragma solidity ^0.4.25;

      import "./ERC721XToken.sol"; import "./Ownable.sol";

      contract ZombieCard is ERC721XToken {

          mapping(uint => uint) internal tokenIdToIndividualSupply;
          mapping(uint => uint) internal nftTokenIdToMouldId;
          uint nftTokenIdIndex = 1000000;

          event TokenAwarded(uint indexed tokenId, address claimer, uint
      amount);

          function name() external view returns (string) {
              return "ZombieCard";
          }

          function symbol() external view returns (string) {
              return "ZCX";
          }

          function individualSupply(uint _tokenId) public view returns (uint) {
              return tokenIdToIndividualSupply[_tokenId];
          }

          function mintToken(uint _tokenId, uint _supply) public onlyOwner {
              require(!exists(_tokenId), "Error: Tried to mint duplicate token
      id");
              _mint(_tokenId, msg.sender, _supply);
              tokenIdToIndividualSupply[_tokenId] = _supply;
          }

          function awardToken(uint _tokenId, address _to, uint _amount) public
      onlyOwner {
              require(exists(_tokenId), "TokenID has not been minted");
              if (individualSupply(_tokenId) > 0) {
                  require(_amount <= balanceOf(msg.sender, _tokenId), "Quantity
      greater than from balance");
                  _updateTokenBalance(msg.sender, _tokenId, _amount,
      ObjectLib.Operations.SUB);
              }
              _updateTokenBalance(_to, _tokenId, _amount,
      ObjectLib.Operations.ADD);
              emit TokenAwarded(_tokenId, _to, _amount);
          }

          function convertToNFT(uint _tokenId, uint _amount) public {
              require(tokenType[_tokenId] == FT);
              require(_amount <= balanceOf(msg.sender, _tokenId), "You do not
      own enough tokens");
              _updateTokenBalance(msg.sender, _tokenId, _amount,
      ObjectLib.Operations.SUB);
              for (uint i = 0; i < _amount; i++) {
                  _mint(nftTokenIdIndex, msg.sender);
                  nftTokenIdToMouldId[nftTokenIdIndex] = _tokenId;
                  nftTokenIdIndex++;
              }
          }

      }
---

ì´ì œ ì´ í•¨ìˆ˜ì˜ ë‚˜ë¨¸ì§€ ë¶€ë¶„ì„ ì™„ì„±í•  ê±¸ì„¸.

ì´ì œ ì´ ì‚¬ìš©ìê°€ ë³€í™˜í•  ì¶©ë¶„í•œ ì–‘ì˜ í† í°ì„ ê°€ì§€ê³  ìˆë‹¤ëŠ” ê²ƒì„ í™•ì¸í–ˆìœ¼ë‹ˆ, ì‹¤ì œë¡œ
ë³€í™˜ì„ í•´ë³¼ ì°¨ë¡€êµ°.

ë³€í™˜ ì‘ì—…ì€ ë‘ ë¶€ë¶„ìœ¼ë¡œ ë‚˜ëˆ„ì–´ì„œ ì§„í–‰í•  ê²ƒì´ë„¤:

1. ì‚¬ìš©ìì˜ `_tokenId` ì”ì•¡ì„ ì¤„ì¼ ê²ƒì´ë„¤ (ê·¸ë¦¬ê³  ì´ í† í°ì„ ë‹¤ë¥¸ ì‚¬ëŒì—ê²Œ ì „ì†¡í•˜
   ëŠ” ê²ƒì´ ì•„ë‹ˆê¸° ë•Œë¬¸ì—, ì‚¬ì‹¤ìƒ "íŒŒê´´"í•˜ëŠ” ê²ƒê³¼ ê°™ë‹¤ë„¤).

2. ê°™ì€ ì–‘ì˜ NFTë¥¼ ë°œí–‰í•˜ê³ , ê°™ì€ ì‚¬ìš©ìì—ê²Œ í• ë‹¹í•  ê²ƒì´ë„¤.

## NFT ë°œí–‰ì´ë€?

ì±•í„° 4ì—ì„œ ë‹¤ì¤‘ ëŒ€ì²´í˜• í† í°ì„ ìƒì„±í•˜ê¸° ìœ„í•´ í˜¸ì¶œí–ˆë˜ `_mint()` í•¨ìˆ˜ë¥¼ ë– ì˜¬ë ¤ë³´ê²Œ
.

ERC721XToken.sol íŒŒì¼ì—ëŠ” ì‚¬ì‹¤ 2ê°œì˜ `_mint` í•¨ìˆ˜ê°€ ìˆë‹¤ë„¤ â€”Â í•˜ë‚˜ëŠ” FTë¥¼ ìœ„í•œ ê²ƒ
ì´ê³ , ë‹¤ë¥¸ í•˜ë‚˜ëŠ” NFTë¥¼ ìœ„í•œ ê²ƒì´ì§€:

```
// FT ë²„ì „ì˜ _mint;
function _mint(uint256 _tokenId, address _to, uint256 _supply) internal;

// NFT ë²„ì „ì˜ _mint;
function _mint(uint256 _tokenId, address _to) internal;
```

ë³´ë‹¤ì‹œí”¼, ë‘˜ì˜ ì°¨ì´ì ì€ í•˜ë‚˜ëŠ” `_supply` ì¸ìë¥¼ ê°€ì§€ê³ , ë‚˜ë¨¸ì§€ëŠ” ê°€ì§€ì§€ ì•ŠëŠ”ë‹¤ë„¤
.

ì†”ë¦¬ë””í‹°ëŠ” ì´ì²˜ëŸ¼ ë§¤ê°œë³€ìˆ˜(ì¸ì)ì˜ ê°œìˆ˜ê°€ ë‹¤ë¥¸ ì—¬ëŸ¬ ë²„ì „ì˜ í•¨ìˆ˜ë¥¼ ê°€ì§ˆ ìˆ˜ ìˆë„ë¡
ì˜¤ë²„ë¡œë”©ì„ í—ˆìš©í•œë‹¤ë„¤.

ê·¸ ë•ë¶„ì— ìš°ë¦¬ëŠ” `ERC721XToken.sol` ì»¨íŠ¸ë™íŠ¸ì— ìˆëŠ” ëª¨ë“  í•¨ìˆ˜ë¥¼ ì˜¤ë²„ë¡œë”©í•˜ì—¬ FT
ì™€ NFT ëª¨ë‘ì— ì ìš©í•  ìˆ˜ ìˆëŠ” ë²„ì „ì„ ê°€ì§ˆ ìˆ˜ ìˆë‹¤ë„¤ â€”Â ì´ê²ƒì´ ê¸°ì¡´ì˜ ERC721 ì„œë¹„ìŠ¤
ì™€ì˜ í•˜ìœ„ í˜¸í™˜ì„ ì œê³µí•˜ëŠ” ê²ƒì´ì§€.

ì¦‰, ì‚¬ìš©ìê°€ ìì‹ ì˜ í† í°ì„ NFTë¡œ ë³€í™˜í•˜ê¸° ìœ„í•´ ì´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ê³  ë‚˜ë©´, ì´ NFTëŠ”
ì´ ëª¨ë“  ì„œë¹„ìŠ¤(ê¸°ì¡´ì˜ ERC721 ì„œë¹„ìŠ¤)ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ ë  ê²ƒì´ë„¤.

# ì§ì ‘ í•´ë³´ê¸°

ì, ì´ì œ ìš°ë¦¬ì˜ í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ ë³´ìê³ .

1. ë¨¼ì €, `_updateTokenBalance`ë¥¼ í˜¸ì¶œí•œ ë’¤, í•´ë‹¹ ì‚¬ìš©ìì˜ `_tokenId` ì”ì•¡ì—ì„œ
   `_amount`ë§Œí¼ ë¹¼ì•¼ í•œë‹¤ë„¤. `awardToken()`ì—ì„œ ì‚¬ìš©í–ˆë˜ ê²ƒê³¼ ê°™ì€ ì½”ë“œë¥¼ ì‚¬ìš©
   í•˜ë©´ ë ê±¸ì„¸.

2. ë‹¤ìŒìœ¼ë¡œ, `for` ë°˜ë³µë¬¸ì„ ìƒì„±í•´ì•¼ í•˜ë„¤. `uint i = 0`ì„ ì„ ì–¸í•˜ê³ ,
   `i < _amount`ë¥¼ ë§Œì¡±í•˜ëŠ” ë™ì•ˆ ê³„ì† ë°˜ë³µí•´ì•¼ í•œë‹¤ë„¤.

3. `for` ë°˜ë³µë¬¸ ì•ˆì—ì„œ ìš°ë¦¬ëŠ” NFT ë²„ì „ì˜ `_mint` í•¨ìˆ˜ë¥¼ í˜¸ì¶œí• ê±¸ì„¸. ì²« ë²ˆì§¸ ì¸ì
   ë¡œ `nftTokenIdIndex`ë¥¼, ë‘ ë²ˆì§¸ ì¸ìë¡œëŠ” `msg.sender`ë¥¼ ì „ë‹¬í•˜ê²Œ. ì´ê²ƒì€ ê³ ìœ
   í•œ IDë¥¼ ê°€ì§„ ìƒˆë¡œìš´ NFTë¥¼ ë°œí–‰í•´ì„œ ê°™ì€ ì‚¬ìš©ìì—ê²Œ í• ë‹¹í•´ì¤„ ê²ƒì´ë„¤.

4. ì´ì œ ì´ ì¹´ë“œê°€ ì–´ë–¤ í‹€(mould)ì˜ ì¼ë¶€ì¸ì§€ ì•Œê¸° ìœ„í•´, ì´ NFTì˜ ì›ë˜
   `_tokenId`ë¥¼ ê°€ì§€ê³  ìˆëŠ” ì½”ë“œê°€ í•„ìš”í•˜ë‹¤ë„¤. ì´ê²ƒì„ ìš°ë¦¬ì˜
   `nftTokenIdToMouldId` ë§¤í•‘ì— ì €ì¥í•˜ê²Œ â€”Â `nftTokenIdIndex`ì— `_tokenId`ë¥¼ ë§¤í•‘
   í•˜ê²Œ.

5. ë§ˆì§€ë§‰ìœ¼ë¡œ, `nftTokenIdIndex++`ë¥¼ í†µí•´ nftTokenIdIndexë¥¼ ì¦ê°€ì‹œì¼œì•¼ í•˜ë„¤ â€”Â ì´
   ê²ƒì€ ë‹¤ìŒì— NFTë¥¼ ìƒì„±í•  ë•Œ, ì´ NFTê°€ ê³ ìœ í•œ IDë¥¼ ê°€ì§ˆ ìˆ˜ ìˆë„ë¡ í•´ì¤€ë‹¤ë„¤.

ì´ê²Œ ì „ë¶€ë¼ë„¤! ì´ í•¨ìˆ˜ëŠ” ì‚¬ìš©ìì˜ ì”ì•¡ì—ì„œ `_amount`ë§Œí¼ì˜ FTë¥¼ ì œí•˜ê³ , ê°™ì€ ì–‘
ì˜ NFTë¥¼ ë°œí–‰í•˜ì—¬ ì‚¬ìš©ìì—ê²Œ ëŒë ¤ì£¼ëŠ” ê²ƒì´ì§€.

NFT ë²„ì „ì˜ `_mint()` í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ë•Œ, ìš°ë¦¬ì˜ ì»¨íŠ¸ë™íŠ¸ëŠ” ë‹¤ìŒ ì´ë²¤íŠ¸ë¥¼ ì „ë‹¬í•  ê²ƒ
ì´ë„¤: `emit Transfer(address(this), _to, _tokenId)` â€” ì´ë¥¼ í†µí•´ ì‚¬ìš©ìê°€ ìì‹ ì´
ë°›ì€ ìƒˆë¡œìš´ NFT í† í°ì˜ IDë¥¼ ì–»ì„ ìˆ˜ ìˆì§€.
