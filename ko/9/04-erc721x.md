---
title: ë°œí–‰í•˜ê¸°
actions: ["checkAnswer", "hints"]
requireLogin: true
material:
  editor:
    language: sol
    startingCode:
      "ZombieCard.sol": |
        pragma solidity ^0.4.25;

        import "./ERC721XToken.sol";
        import "./Ownable.sol";

        contract ZombieCard is ERC721XToken {

            mapping(uint => uint) internal tokenIdToIndividualSupply;

            function name() external view returns (string) {
                return "ZombieCard";
            }

            function symbol() external view returns (string) {
                return "ZCX";
            }

            function individualSupply(uint _tokenId) public view returns (uint) {
                return tokenIdToIndividualSupply[_tokenId];
            }

            // ì—¬ê¸°ì„œ ì‹œì‘í•˜ê²Œ

        }
      "ERC721XToken.sol": |

        // Full implementation with all included files at https://github.com/loomnetwork/erc721x

        pragma solidity ^0.4.25;

        import "./../../Interfaces/ERC721X.sol";

        import "./../../Interfaces/ERC721XReceiver.sol";
        import "./ERC721XTokenNFT.sol";

        import "openzeppelin-solidity/contracts/AddressUtils.sol";
        import "./../../Libraries/ObjectsLib.sol";


        // Additional features over NFT token that is compatible with batch transfers
        contract ERC721XToken is ERC721X, ERC721XTokenNFT {

            using ObjectLib for ObjectLib.Operations;
            using AddressUtils for address;

            bytes4 internal constant ERC721X_RECEIVED = 0x660b3370;
            bytes4 internal constant ERC721X_BATCH_RECEIVE_SIG = 0xe9e5be6a;

            event BatchTransfer(address from, address to, uint256[] tokenTypes, uint256[] amounts);


            modifier isOperatorOrOwner(address _from) {
                require((msg.sender == _from) || operators[_from][msg.sender], "msg.sender is neither _from nor operator");
                _;
            }

            function implementsERC721X() public pure returns (bool) {
                return true;
            }

            /**
             * @dev transfer objects from different tokenIds to specified address
             * @param _from The address to BatchTransfer objects from.
             * @param _to The address to batchTransfer objects to.
             * @param _tokenIds Array of tokenIds to update balance of
             * @param _amounts Array of amount of object per type to be transferred.
             * Note:  Arrays should be sorted so that all tokenIds in a same bin are adjacent (more efficient).
             */
            function _batchTransferFrom(address _from, address _to, uint256[] _tokenIds, uint256[] _amounts)
                internal
                isOperatorOrOwner(_from)
            {

                // Requirements
                require(_tokenIds.length == _amounts.length, "Inconsistent array length between args");
                require(_to != address(0), "Invalid recipient");

                if (tokenType[_tokenIds[0]] == NFT) {
                    tokenOwner[_tokenIds[0]] = _to;
                    emit Transfer(_from, _to, _tokenIds[0]);
                }

                // Load first bin and index where the object balance exists
                (uint256 bin, uint256 index) = ObjectLib.getTokenBinIndex(_tokenIds[0]);

                // Balance for current bin in memory (initialized with first transfer)
                // Written with bad library syntax instead of as below to bypass stack limit error
                uint256 balFrom = ObjectLib.updateTokenBalance(
                    packedTokenBalance[_from][bin], index, _amounts[0], ObjectLib.Operations.SUB
                );
                uint256 balTo = ObjectLib.updateTokenBalance(
                    packedTokenBalance[_to][bin], index, _amounts[0], ObjectLib.Operations.ADD
                );

                // Number of transfers to execute
                uint256 nTransfer = _tokenIds.length;

                // Last bin updated
                uint256 lastBin = bin;

                for (uint256 i = 1; i < nTransfer; i++) {
                    // If we're transferring an NFT we additionally should update the tokenOwner and emit the corresponding event
                    if (tokenType[_tokenIds[i]] == NFT) {
                        tokenOwner[_tokenIds[i]] = _to;
                        emit Transfer(_from, _to, _tokenIds[i]);
                    }
                    (bin, index) = _tokenIds[i].getTokenBinIndex();

                    // If new bin
                    if (bin != lastBin) {
                        // Update storage balance of previous bin
                        packedTokenBalance[_from][lastBin] = balFrom;
                        packedTokenBalance[_to][lastBin] = balTo;

                        // Load current bin balance in memory
                        balFrom = packedTokenBalance[_from][bin];
                        balTo = packedTokenBalance[_to][bin];

                        // Bin will be the most recent bin
                        lastBin = bin;
                    }

                    // Update memory balance
                    balFrom = balFrom.updateTokenBalance(index, _amounts[i], ObjectLib.Operations.SUB);
                    balTo = balTo.updateTokenBalance(index, _amounts[i], ObjectLib.Operations.ADD);
                }

                // Update storage of the last bin visited
                packedTokenBalance[_from][bin] = balFrom;
                packedTokenBalance[_to][bin] = balTo;

                // Emit batchTransfer event
                emit BatchTransfer(_from, _to, _tokenIds, _amounts);
            }

            function batchTransferFrom(address _from, address _to, uint256[] _tokenIds, uint256[] _amounts) public {
                // Batch Transfering
                _batchTransferFrom(_from, _to, _tokenIds, _amounts);
            }

            /**
             * @dev transfer objects from different tokenIds to specified address
             * @param _from The address to BatchTransfer objects from.
             * @param _to The address to batchTransfer objects to.
             * @param _tokenIds Array of tokenIds to update balance of
             * @param _amounts Array of amount of object per type to be transferred.
             * @param _data Data to pass to onERC721XReceived() function if recipient is contract
             * Note:  Arrays should be sorted so that all tokenIds in a same bin are adjacent (more efficient).
             */
            function safeBatchTransferFrom(
                address _from,
                address _to,
                uint256[] _tokenIds,
                uint256[] _amounts,
                bytes _data
            )
                public
            {

                // Batch Transfering
                _batchTransferFrom(_from, _to, _tokenIds, _amounts);

                // Pass data if recipient is contract
                if (_to.isContract()) {
                    bytes4 retval = ERC721XReceiver(_to).onERC721XBatchReceived(
                        msg.sender, _from, _tokenIds, _amounts, _data
                    );
                    require(retval == ERC721X_BATCH_RECEIVE_SIG);
                }
            }

            function transfer(address _to, uint256 _tokenId, uint256 _amount) public {
                _transferFrom(msg.sender, _to, _tokenId, _amount);
            }

            function transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public {
                _transferFrom(_from, _to, _tokenId, _amount);
            }

            function _transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount)
                internal
                isOperatorOrOwner(_from)
            {
                require(tokenType[_tokenId] == FT);
                require(_amount <= balanceOf(_from, _tokenId), "Quantity greater than from balance");
                require(_to != address(0), "Invalid to address");

                _updateTokenBalance(_from, _tokenId, _amount, ObjectLib.Operations.SUB);
                _updateTokenBalance(_to, _tokenId, _amount, ObjectLib.Operations.ADD);
                emit TransferWithQuantity(_from, _to, _tokenId, _amount);
            }

            function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public {
                safeTransferFrom(_from, _to, _tokenId, _amount, "");
            }

            function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount, bytes _data) public {
                _transferFrom(_from, _to, _tokenId, _amount);
                require(
                    checkAndCallSafeTransfer(_from, _to, _tokenId, _amount, _data),
                    "Sent to a contract which is not an ERC721X receiver"
                );
            }

            function _mint(uint256 _tokenId, address _to, uint256 _supply) internal {
                // If the token doesn't exist, add it to the tokens array
                if (!exists(_tokenId)) {
                    tokenType[_tokenId] = FT;
                    allTokens.push(_tokenId);
                } else {
                    // if the token exists, it must be a FT
                    require(tokenType[_tokenId] == FT, "Not a FT");
                }

                _updateTokenBalance(_to, _tokenId, _supply, ObjectLib.Operations.ADD);
                emit TransferWithQuantity(address(this), _to, _tokenId, _supply);
            }


            function checkAndCallSafeTransfer(
                address _from,
                address _to,
                uint256 _tokenId,
                uint256 _amount,
                bytes _data
            )
                internal
                returns (bool)
            {
                if (!_to.isContract()) {
                    return true;
                }

                bytes4 retval = ERC721XReceiver(_to).onERC721XReceived(
                    msg.sender, _from, _tokenId, _amount, _data);
                return(retval == ERC721X_RECEIVED);
            }

        }
      "Ownable.sol": |
        pragma solidity ^0.4.25;

        /**
         * @title Ownable
         * @dev The Ownable contract has an owner address, and provides basic authorization control
         * functions, this simplifies the implementation of "user permissions".
         */
        contract Ownable {
          address private _owner;

          event OwnershipTransferred(
            address indexed previousOwner,
            address indexed newOwner
          );

          /**
           * @dev The Ownable constructor sets the original `owner` of the contract to the sender
           * account.
           */
          constructor() internal {
            _owner = msg.sender;
            emit OwnershipTransferred(address(0), _owner);
          }

          /**
           * @return the address of the owner.
           */
          function owner() public view returns(address) {
            return _owner;
          }

          /**
           * @dev Throws if called by any account other than the owner.
           */
          modifier onlyOwner() {
            require(isOwner());
            _;
          }

          /**
           * @return true if `msg.sender` is the owner of the contract.
           */
          function isOwner() public view returns(bool) {
            return msg.sender == _owner;
          }

          /**
           * @dev Allows the current owner to relinquish control of the contract.
           * @notice Renouncing to ownership will leave the contract without an owner.
           * It will not be possible to call the functions with the `onlyOwner`
           * modifier anymore.
           */
          function renounceOwnership() public onlyOwner {
            emit OwnershipTransferred(_owner, address(0));
            _owner = address(0);
          }

          /**
           * @dev Allows the current owner to transfer control of the contract to a newOwner.
           * @param newOwner The address to transfer ownership to.
           */
          function transferOwnership(address newOwner) public onlyOwner {
            _transferOwnership(newOwner);
          }

          /**
           * @dev Transfers control of the contract to a newOwner.
           * @param newOwner The address to transfer ownership to.
           */
          function _transferOwnership(address newOwner) internal {
            require(newOwner != address(0));
            emit OwnershipTransferred(_owner, newOwner);
            _owner = newOwner;
          }
        }
    answer: >
      pragma solidity ^0.4.25;

      import "./ERC721XToken.sol"; import "./Ownable.sol";

      contract ZombieCard is ERC721XToken {

          mapping(uint => uint) internal tokenIdToIndividualSupply;

          function name() external view returns (string) {
              return "ZombieCard";
          }

          function symbol() external view returns (string) {
              return "ZCX";
          }

          function individualSupply(uint _tokenId) public view returns (uint) {
              return tokenIdToIndividualSupply[_tokenId];
          }

          function mintToken(uint _tokenId, uint _supply) public onlyOwner {
              require(!exists(_tokenId), "Error: Tried to mint duplicate token
      id");
              _mint(_tokenId, msg.sender, _supply);
              tokenIdToIndividualSupply[_tokenId] = _supply;
          }

      }
---

í›Œë¥­í•˜êµ°! ì´ì œ ìš°ë¦¬ì˜ ì²« ì¹´ë“œë“¤ì„ ë°œí–‰í•  ì‹œê°„ì´ë„¤.

ì¹´ë“œ ë°œí–‰ì„ ìœ„í•´ì„œ ìš°ë¦¬ëŠ” `mintToken`ì´ë¼ëŠ” í•¨ìˆ˜ë¥¼ êµ¬í˜„í•  ê²ƒì´ë„¤. ìƒˆë¡œìš´ ì¹´ë“œ í…œ
í”Œë¦¿ë“¤ì„ ì‹¤ì œë¡œ ë§Œë“¤ì–´ë‚´ê¸° ìœ„í•´ ì»¨íŠ¸ë™íŠ¸ ì†Œìœ ìê°€ í˜¸ì¶œí•  ìˆ˜ ìˆëŠ” í•¨ìˆ˜ì´ì§€.

ìƒì„± ì‹œì ì—, ê° ì¹´ë“œ í…œí”Œë¦¿ì—ëŠ” ì‹ë³„ìë¡œì„œ ê³ ìœ í•œ `_tokenId`ë¥¼ ì „ë‹¬í•´ì•¼ í•˜ê³ ,
`_supply`ë„ ì „ë‹¬í•´ì•¼ í•˜ë„¤ - ë§Œë“¤ì–´ì§€ëŠ” ì¹´ë“œì˜ ê°œìˆ˜ì´ì§€.

ìš°ë¦¬ëŠ” ì»¨íŠ¸ë™íŠ¸ì˜ ì†Œìœ ìë§Œ `mintToken` í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆê¸°ë¥¼ ì›í•˜ê¸° ë•Œë¬¸ì—,
`Ownable.sol`ì„ í¬í•¨ì‹œí‚¤ê³  ìš°ë¦¬ ì»¨íŠ¸ë™íŠ¸ì— `import` êµ¬ë¬¸ì„ ì¶”ê°€í•˜ì˜€ë„¤(ìš°ë¦¬ê°€
<a href="https://cryptozombies.io/en/lesson/3/chapter/2">ë ˆìŠ¨3 ì±•í„°2</a>ì—ì„œ ë‹¤
ë¤˜ë“¯ì´ ë§ì´ì§€). ì´ì œ ìë„¤ëŠ” `onlyOwner` ì œì–´ìë¥¼ ìš°ë¦¬ê°€ ë§Œë“¤ë ¤ í•˜ëŠ” `mintToken`
í•¨ìˆ˜ì— ì‚¬ìš©í•  ìˆ˜ ìˆë„¤.

ìš°ë¦¬ê°€ í† í°ì„ ë°œí–‰í•  ë•Œ ê·¸ ë’¤ì—ì„œ ì–´ë–¤ ì¼ë“¤ì´ ì¼ì–´ë‚˜ëŠ”ì§€ ì•Œì•„ë³´ë„ë¡ í•˜ì§€.

### `_mint`

ìš°ë¦¬ê°€ ìƒì†í•˜ëŠ” `ERC721XToken` ì»¨íŠ¸ë™íŠ¸ì—ëŠ” `_mint`ë¼ëŠ” ì´ë¦„ì˜ í•¨ìˆ˜ê°€ ìˆë„¤.

```
function _mint(uint256 _tokenId, address _to, uint256 _supply) internal;
```

ì´ëŠ” ì»¨íŠ¸ë™íŠ¸ì—ì„œ ìƒˆë¡œìš´ ì¹´ë“œ í…œí”Œë¦¿ì„ ì •ì˜í•  ë•Œ ì“°ì´ëŠ” internal í•¨ìˆ˜ì´ì§€.

ì´ì œ ìš°ë¦¬ì˜ ê²Œì„ ì„œë²„(ë˜ëŠ” ì‚¬ì´ë“œì²´ì¸ - ìë„¤ê°€ Loomì„ í†µí•´ ì™„ì „í•œ ë¸”ë¡ì²´ì¸ ê¸°ë°˜
ê²Œì„ì„ ë§Œë“ ë‹¤ë©´ ë§ì´ì§€)ì—ì„œ ìƒˆë¡œìš´ í† í°ë“¤ì„ ë§Œë“¤ê¸° ìœ„í•´ í˜¸ì¶œí•  ìˆ˜ ìˆëŠ” public í•¨
ìˆ˜ë¥¼ ë§Œë“¤ë„ë¡ í•˜ê² ë„¤.

# ì§ì ‘ í•´ë³´ê¸°

1. `mintToken`ì´ë¼ëŠ” ì´ë¦„ì˜ í•¨ìˆ˜ë¥¼ ë§Œë“¤ê²Œ. ì´ í•¨ìˆ˜ëŠ” 2ê°œì˜ ì¸ìë¡œ
   `uint _tokenId`ì™€ `uint _supply`ë¥¼ ë°›ì•„ì•¼ í•˜ë„¤. ë˜ `public`ì´ì–´ì•¼ í•˜ê³ ,
   `onlyOwner` ì œì–´ìë¥¼ ê°€ì ¸ì•¼ í•˜ë„¤.

2. í¬ê·€í•œ í•œì •íŒ ì¹´ë“œë¼ê³  ë§í•˜ë ¤ë©´ ê·¸ ì–‘ì´ í™•ì‹¤íˆ ì œí•œë˜ì–´ ìˆì–´ì•¼ í•˜ëŠ” ê²ƒì´ì§€.
   ì´ëŠ” ìš°ë¦¬ê°€ í•œ í† í°ì„ í•œ ë²ˆë§Œ ë°œí–‰í•  ìˆ˜ ìˆì–´ì•¼ í•˜ê³ , ê·¸ ê³µê¸‰ëŸ‰ì„ ë‹¤ì‹œ ëŠ˜ë¦´ ìˆ˜
   ëŠ” ì—†ì–´ì•¼ í•˜ëŠ” ê²ƒì´ë„¤.

ìš°ë¦¬ëŠ” ì´ë¥¼ `require` êµ¬ë¬¸ì„ ì‚¬ìš©í•˜ì—¬ ë³´ì¥í•  ìˆ˜ ìˆì§€. í•´ë‹¹ í† í°ì´ ì´ë¯¸ ì¡´ì¬í•œë‹¤
ë©´ ì—ëŸ¬ë¥¼ ë‚´ë©° ì¢…ë£Œë˜ë„ë¡ í•´ì„œ ë§ì´ë„¤. ì´ë ‡ê²Œ í•˜ë ¤ë©´ ìš°ë¦¬ê°€ `ERC721XToken.sol`ì—
ì„œ ì •ì˜í•œ í•¨ìˆ˜ë¥¼ ì“°ê¸° ì „ì— ë‹¤ìŒ í•œ ì¤„ì˜ ì½”ë“œë¥¼ ì“°ë©´ ë˜ë„¤:
`require(!exists(_tokenId), "Error: Tried to mint duplicate token id");`

ì´ ì½”ë“œë¥¼ ìš°ë¦¬ í•¨ìˆ˜ì˜ ì²« ë²ˆì§¸ ì¤„ì— ë‘ê²Œ.

3. ë‹¤ìŒìœ¼ë¡œ, ìœ„ì˜ ì˜ˆì‹œì—ì„œì²˜ëŸ¼ internal í•¨ìˆ˜ì¸ `_mint`ë¥¼ í˜¸ì¶œí•  ê²ƒì´ë„¤. ì´ í•¨ìˆ˜
   ì—ëŠ” ì¸ìë¡œ `_tokenId, msg.sender, _supply` 3ê°œë¥¼ ì „ë‹¬í•  ê²ƒì´ë„¤.

4. ë§ˆì§€ë§‰ìœ¼ë¡œ, ìš°ë¦¬ì˜ mapping `tokenIdToIndividualSupply`ë¥¼ ì´ í† í°ì˜ ê³µê¸‰ëŸ‰ì„
   ì €ì¥í•˜ë„ë¡ ì—…ë°ì´íŠ¸í•´ì•¼ í•˜ë„¤. ì´ ë§¤í•‘ì˜ `_tokenId`ì— í•´ë‹¹í•˜ëŠ” ê°’ì„
   `_supply`ë¡œ ì„¤ì •í•˜ë„ë¡ ì—…ë°ì´íŠ¸í•˜ê²Œ.

ì´ê²Œ ëì´ë„¤! ì´ì œ ìš°ë¦¬ëŠ” ì»¨íŠ¸ë™íŠ¸(ìš°ë¦¬ ê²Œì„)ì˜ ì†Œìœ ìê°€ ìƒˆ ì¹´ë“œë¥¼ ë§Œë“¤ ë•Œ í˜¸ì¶œí•
ìˆ˜ ìˆëŠ” í¼ë¸”ë¦­ `mintToken` í•¨ìˆ˜ë¥¼ ê°€ì§€ê²Œ ë˜ì—ˆë„¤.
