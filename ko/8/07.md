---
title: ëœë¤ ë™ì „ ë˜ì§€ê¸°
actions: ["checkAnswer", "hints"]
requireLogin: true
material:
  editor:
    language: solidity
    startingCode:
      "zombiepile.sol": |
        pragma solidity 0.4.25;

        import "./ZB/ZBGameMode.sol";

        contract ZombiePile is ZBGameMode  {

            function beforeMatchStart(bytes serializedGameState) external {

                GameState memory gameState;
                gameState.init(serializedGameState);

                ZBSerializer.SerializedGameStateChanges memory changes;
                changes.init();

                CardInstance[] memory player1Cards = new CardInstance[](gameState.playerStates[0].cardsInDeck.length);
                CardInstance[] memory player2Cards = new CardInstance[](gameState.playerStates[1].cardsInDeck.length);
                uint player1CardCount = 0;
                uint player2CardCount = 0;


                for (uint i = 0; i < gameState.playerStates.length; i++) {
                    for (uint j = 0; j < gameState.playerStates[i].cardsInDeck.length; j++) {
                        // 1. ì´ ë°˜ë³µë¬¸ ì•ˆì˜ ë¡œì§ì„ ëª¨ë‘ ì§€ìš°ê³ , ì—¬ê¸°ì„œ ì‹œì‘í•˜ê²Œ
                        bool cardAlreadyInDeck = false;

                        for (uint k = 0; k < cardCount; k++) {
                            if (keccak256(abi.encodePacked(newCards[k].mouldName)) == keccak256(abi.encodePacked(gameState.playerStates[i].cardsInDeck[j].mouldName))) {
                                cardAlreadyInDeck = true;
                            }
                        }

                        if (!cardAlreadyInDeck) {
                            newCards[cardCount] = gameState.playerStates[i].cardsInDeck[j];
                            cardCount++;
                        }

                    }

                    changes.changePlayerCardsInDeck(Player(i), newCards, cardCount);
                }

                changes.emit();

            }

        }
      "singleton.sol": |
        pragma solidity 0.4.25;

        import "./ZB/ZBGameMode.sol";

        contract Singleton is ZBGameMode  {

            function beforeMatchStart(bytes serializedGameState) external {

                GameState memory gameState;
                gameState.init(serializedGameState);

                ZBSerializer.SerializedGameStateChanges memory changes;
                changes.init();

                for (uint i = 0; i < gameState.playerStates.length; i++) {
                    CardInstance[] memory newCards = new CardInstance[](gameState.playerStates[i].cardsInDeck.length);
                    uint cardCount = 0;

                    for (uint j = 0; j < gameState.playerStates[i].cardsInDeck.length; j++) {
                        bool cardAlreadyInDeck = false;

                        for (uint k = 0; k < cardCount; k++) {
                            if (keccak256(abi.encodePacked(newCards[k].mouldName)) == keccak256(abi.encodePacked(gameState.playerStates[i].cardsInDeck[j].mouldName))) {
                                cardAlreadyInDeck = true;
                            }
                        }

                        if (!cardAlreadyInDeck) {
                            newCards[cardCount] = gameState.playerStates[i].cardsInDeck[j];
                            cardCount++;
                        }

                    }

                    changes.changePlayerCardsInDeck(Player(i), newCards, cardCount);
                }

                changes.emit();

            }

        }
      "munchkin.sol": |
        pragma solidity 0.4.25;

        import "./ZB/ZBGameMode.sol";

        contract Munchkin is ZBGameMode  {

            function beforeMatchStart(bytes serializedGameState) external {

                GameState memory gameState;
                gameState.init(serializedGameState);

                ZBSerializer.SerializedGameStateChanges memory changes;
                changes.init();

                for (uint i = 0; i < gameState.playerStates.length; i++) {
                    CardInstance[] memory newCards = new CardInstance[](gameState.playerStates[i].cardsInDeck.length);
                    uint cardCount = 0;

                    for (uint j = 0; j < gameState.playerStates[i].cardsInDeck.length; j++) {
                        if (isLegalCard(gameState.playerStates[i].cardsInDeck[j])) {
                            newCards[cardCount] = gameState.playerStates[i].cardsInDeck[j];
                            cardCount++;
                        }
                    }

                    changes.changePlayerCardsInDeck(Player(i), newCards, cardCount);
                }

                changes.emit();

            }

            function isLegalCard(CardInstance card) internal view returns(bool) {
                return (card.gooCost <= 2);
            }

        }
      "ZBGameMode.sol": |
        // This file is here for your reference, but doesn't contain all the imports necessary
        // to compile. You can find a repo with all the final files at:
        // https://github.com/loomnetwork/zb_game_mode

        pragma solidity ^0.4.25;

        import "./ZBEnum.sol";
        import "./ZBSerializer.sol";

        contract ZBGameMode {
            using ZBSerializer for ZBSerializer.SerializedGameStateChanges;
            using ZBSerializer for GameState;

            enum Player {
                Player1,
                Player2
            }

            struct PlayerState {
                string id;
                //PlayerActionType currentAction = 2;
                //OverlordInstance overlordInstance = 3;
                CardInstance[] cardsInHand;
                //CardInstance[] CardsInPlay;
                CardInstance[] cardsInDeck;
                Deck deck;
                uint8 defense;
                uint8 currentGoo;
                uint8 gooVials;
                uint32 turnTime;
                //bool hasDrawnCard = 11;
                //repeated CardInstance cardsInGraveyard = 12;
                uint8 initialCardsInHandCount;
                uint8 maxCardsInPlay;
                uint8 maxCardsInHand;
                uint8 maxGooVials;
            }

            struct Deck {
                int64 id;
                string name;
                int64 heroId;
            }

            struct CardInstance {
                int32 instanceId;
                string mouldName;
                int32 defense;
                bool defenseInherited;
                int32 attack;
                bool attackInherited;
                int32 gooCost;
                bool gooCostInherited;
            }

            struct GameState {
                int64 id;
                uint8 currentPlayerIndex;
                PlayerState[] playerStates;
            }

            struct Vector2Int {
                int32 x;
                int32 y;
            }

            struct Rect {
                Vector2Int position;
                Vector2Int size;
            }

            struct CustomUiLabel {
                Rect rect;
                string text;
            }

            struct CustomUiButton {
                Rect rect;
                string title;
                bytes onClickCallData;
            }

            event GameStateChanges (
                bytes serializedChanges
            );

            function getInterfaceVersion() external pure returns (int) {
                return 1;
            }

            function getDataStructureVersion() external pure returns (int) {
                return 1;
            }

            function beforeMatchStart(bytes) external {
            }

            function afterInitialDraw(bytes) external {
            }

            function getCustomUi() external view returns (bytes) {
                return new bytes(0);
            }
        }
      "ZBSerializer.sol": |
        // This file is here for your reference, but doesn't contain all the imports necessary
        // to compile. You can find a repo with all the final files at:
        // https://github.com/loomnetwork/zb_game_mode

        pragma solidity ^0.4.25;

        import "./ZBEnum.sol";
        import "./ZBGameMode.sol";
        import "./SerialityBinaryStream.sol";

        library ZBSerializer {
            using SerialityBinaryStream for SerialityBinaryStream.BinaryStream;
            uint constant defaultSerializedGameStateChangesBufferSize = 512;
            uint constant defaultSerializedCustomUiBufferSize = 512;

            event GameStateChanges (
                bytes serializedChanges
            );

            struct SerializedGameStateChanges {
                SerialityBinaryStream.BinaryStream stream;
            }

            struct SerializedCustomUi {
                SerialityBinaryStream.BinaryStream stream;
            }

            // GameState deserialization

            function init(ZBGameMode.GameState memory self, bytes serializedGameState) internal pure {
                SerialityBinaryStream.BinaryStream memory stream =
                    SerialityBinaryStream.BinaryStream(serializedGameState, serializedGameState.length);

                self.id = stream.readInt64();
                self.currentPlayerIndex = stream.readUint8();

                self.playerStates = new ZBGameMode.PlayerState[](2);
                for (uint i = 0; i < self.playerStates.length; i++) {
                    self.playerStates[i] = deserializePlayerState(stream);
                }
            }

            function deserializePlayerState(SerialityBinaryStream.BinaryStream memory stream) private pure returns (ZBGameMode.PlayerState) {
                ZBGameMode.PlayerState memory player;

                player.id = stream.readString();
                player.deck = deserializeDeck(stream);
                player.cardsInHand = deserializeCardInstanceArray(stream);
                player.cardsInDeck = deserializeCardInstanceArray(stream);
                player.defense = stream.readUint8();
                player.currentGoo = stream.readUint8();
                player.gooVials = stream.readUint8();
                player.turnTime = stream.readUint32();
                player.initialCardsInHandCount = stream.readUint8();
                player.maxCardsInPlay = stream.readUint8();
                player.maxCardsInHand = stream.readUint8();
                player.maxGooVials = stream.readUint8();

                return player;
            }

            function serializeCardInstance(SerialityBinaryStream.BinaryStream memory stream, ZBGameMode.CardInstance card) private pure {
                stream.writeInt32(card.instanceId);
                stream.writeString(card.mouldName);
                stream.writeInt32(card.defense);
                stream.writeBool(card.attackInherited);
                stream.writeInt32(card.attack);
                stream.writeBool(card.defenseInherited);
                stream.writeInt32(card.gooCost);
                stream.writeBool(card.gooCostInherited);
            }

            function deserializeCardInstance(SerialityBinaryStream.BinaryStream memory stream) private pure returns (ZBGameMode.CardInstance) {
                ZBGameMode.CardInstance memory card;

                card.instanceId = stream.readInt32();
                card.mouldName = stream.readString();
                card.defense = stream.readInt32();
                card.defenseInherited = stream.readBool();
                card.attack = stream.readInt32();
                card.attackInherited = stream.readBool();
                card.gooCost = stream.readInt32();
                card.gooCostInherited = stream.readBool();

                return card;
            }

            function serializeCardInstanceArray(SerialityBinaryStream.BinaryStream memory stream, ZBGameMode.CardInstance[] cards) internal pure {
                stream.writeUint32(uint32(cards.length));

                for (uint i = 0; i < cards.length; i++) {
                    serializeCardInstance(stream, cards[i]);
                }
            }

            function deserializeCardInstanceArray(SerialityBinaryStream.BinaryStream memory stream) private pure returns (ZBGameMode.CardInstance[]) {
                uint count = stream.readUint32();

                ZBGameMode.CardInstance[] memory cards = new ZBGameMode.CardInstance[](count);
                for (uint i = 0; i < count; i++) {
                    cards[i] = deserializeCardInstance(stream);
                }

                return cards;
            }

            function deserializeDeck(SerialityBinaryStream.BinaryStream memory stream) private pure returns (ZBGameMode.Deck) {
                ZBGameMode.Deck memory deck;
                deck.id = stream.readInt64();
                deck.name = stream.readString();
                deck.heroId = stream.readInt64();

                return deck;
            }

            function serializeStartGameStateChangeAction(
                SerialityBinaryStream.BinaryStream memory stream,
                ZBEnum.GameStateChangeAction action
                ) private pure {
                stream.writeUint32(uint32(action));
            }

            function serializeStartGameStateChangeAction(
                SerialityBinaryStream.BinaryStream memory stream,
                ZBEnum.GameStateChangeAction action,
                ZBGameMode.Player player
                ) private pure {
                stream.writeUint32(uint32(action));
                stream.writeUint8(uint8(player));
            }

            // CardInstance

            function changeMouldName(ZBGameMode.CardInstance memory self, string mouldName) internal pure {
                self.mouldName = mouldName;
            }

            function changeDefense(ZBGameMode.CardInstance memory self, uint8 defense) internal pure {
                self.defense = defense;
                self.defenseInherited = false;
            }

            function changeAttack(ZBGameMode.CardInstance memory self, uint8 attack) internal pure {
                self.attack = attack;
                self.attackInherited = false;
            }

            function changeGooCost(ZBGameMode.CardInstance memory self, uint8 gooCost) internal pure {
                self.gooCost = gooCost;
                self.gooCostInherited = false;
            }

            // SerializedGameStateChanges

            function init(SerializedGameStateChanges memory self) internal pure {
                init(self, defaultSerializedGameStateChangesBufferSize);
            }

            function init(SerializedGameStateChanges memory self, uint bufferSize) internal pure {
                self.stream = SerialityBinaryStream.BinaryStream(new bytes(bufferSize), bufferSize);
            }

            function getBytes(SerializedGameStateChanges memory self) internal pure returns (bytes) {
                return self.stream.buffer;
            }

            function emit(SerializedGameStateChanges memory self) internal {
                emit GameStateChanges(getBytes(self));
            }

            function changePlayerDefense(SerializedGameStateChanges memory self, ZBGameMode.Player player, uint8 defense) internal pure returns (uint) {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerDefense, player);
                stream.writeUint8(uint8(defense));
            }

            function changePlayerCurrentGoo(SerializedGameStateChanges memory self, ZBGameMode.Player player, uint8 currentGoo) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerCurrentGoo, player);
                stream.writeUint8(uint8(currentGoo));
            }

            function changePlayerCurrentGooVials(SerializedGameStateChanges memory self, ZBGameMode.Player player, uint8 gooVials) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerGooVials, player);
                stream.writeUint8(uint8(gooVials));
            }

            function changePlayerCardsInDeck(
                SerializedGameStateChanges memory self,
                ZBGameMode.Player player,
                ZBGameMode.CardInstance[] cards,
                uint cardCount
                ) internal pure {
                require(
                    cardCount <= cards.length,
                    "cardCount > cards.length"
                );

                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerCardsInDeck, player);
                stream.writeUint32(uint32(cardCount));

                for (uint i = 0; i < cardCount; i++) {
                    serializeCardInstance(stream, cards[i]);
                }
            }

            function changePlayerCardsInDeck(
                SerializedGameStateChanges memory self,
                ZBGameMode.Player player,
                ZBGameMode.CardInstance[] cards
                ) internal pure {
                changePlayerCardsInDeck(self, player, cards, cards.length);
            }

            function changePlayerCardsInHand(
                SerializedGameStateChanges memory self,
                ZBGameMode.Player player,
                ZBGameMode.CardInstance[] cards,
                uint cardCount
                ) internal pure {
                require(
                    cardCount <= cards.length,
                    "cardCount > cards.length"
                );

                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerCardsInHand, player);
                stream.writeUint32(uint32(cardCount));

                for (uint i = 0; i < cardCount; i++) {
                    serializeCardInstance(stream, cards[i]);
                }
            }

            function changePlayerCardsInHand(
                SerializedGameStateChanges memory self,
                ZBGameMode.Player player,
                ZBGameMode.CardInstance[] cards
                ) internal pure {
                changePlayerCardsInHand(self, player, cards, cards.length);
            }

            function changePlayerInitialCardsInHandCount(SerializedGameStateChanges memory self, ZBGameMode.Player player, uint8 count) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerInitialCardsInHandCount, player);
                stream.writeUint8(count);
            }

            function changePlayerMaxCardsInPlay(SerializedGameStateChanges memory self, ZBGameMode.Player player, uint8 count) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerMaxCardsInPlay, player);
                stream.writeUint8(count);
            }

            function changePlayerMaxCardsInHand(SerializedGameStateChanges memory self, ZBGameMode.Player player, uint8 count) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerMaxCardsInHand, player);
                stream.writeUint8(count);
            }

            function changePlayerMaxGooVials(SerializedGameStateChanges memory self, ZBGameMode.Player player, uint8 count) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerMaxGooVials, player);
                stream.writeUint8(count);
            }

            function changePlayerTurnTime(SerializedGameStateChanges memory self, ZBGameMode.Player player, uint32 turnTime) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerTurnTime, player);
                stream.writeUint32(turnTime);
            }

            // SerializedCustomUi

            function init(SerializedCustomUi memory self) internal pure {
                init(self, defaultSerializedCustomUiBufferSize);
            }

            function init(SerializedCustomUi memory self, uint bufferSize) internal pure {
                self.stream = SerialityBinaryStream.BinaryStream(new bytes(bufferSize), bufferSize);
            }

            function getBytes(SerializedCustomUi memory self) internal pure returns (bytes) {
                return self.stream.buffer;
            }

            function add(SerializedCustomUi memory self, ZBGameMode.CustomUiLabel label) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartCustomUiElement(stream, ZBEnum.CustomUiElement.Label, label.rect);
                stream.writeString(label.text);
            }

            function add(SerializedCustomUi memory self, ZBGameMode.CustomUiButton button) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartCustomUiElement(stream, ZBEnum.CustomUiElement.Button, button.rect);
                stream.writeString(button.title);
                stream.writeBytes(button.onClickCallData);
            }

            function serializeStartCustomUiElement(SerialityBinaryStream.BinaryStream memory stream, ZBEnum.CustomUiElement element) private pure {
                stream.writeInt32(int32(element));
            }

            function serializeStartCustomUiElement(
                SerialityBinaryStream.BinaryStream memory stream,
                ZBEnum.CustomUiElement element,
                ZBGameMode.Rect rect
                ) private pure {
                serializeStartCustomUiElement(stream, element);
                serializeRect(stream, rect);
            }

            function serializeRect(SerialityBinaryStream.BinaryStream memory stream, ZBGameMode.Rect rect) private pure {
                serializeVector2Int(stream, rect.position);
                serializeVector2Int(stream, rect.size);
            }

            function serializeVector2Int(SerialityBinaryStream.BinaryStream memory stream, ZBGameMode.Vector2Int v) private pure {
                stream.writeInt32(v.x);
                stream.writeInt32(v.y);
            }
        }
    answer: |
      pragma solidity 0.4.25;

      import "./ZB/ZBGameMode.sol";

      contract ZombiePile is ZBGameMode  {

          function beforeMatchStart(bytes serializedGameState) external {

              GameState memory gameState;
              gameState.init(serializedGameState);

              ZBSerializer.SerializedGameStateChanges memory changes;
              changes.init();

              CardInstance[] memory player1Cards = new CardInstance[](gameState.playerStates[0].cardsInDeck.length);
              CardInstance[] memory player2Cards = new CardInstance[](gameState.playerStates[1].cardsInDeck.length);
              uint player1CardCount = 0;
              uint player2CardCount = 0;

              for (uint i = 0; i < gameState.playerStates.length; i++) {
                  for (uint j = 0; j < gameState.playerStates[i].cardsInDeck.length; j++) {
                      uint rand = uint(keccak256(abi.encodePacked(now, player1CardCount + player2CardCount))) % 2;
                      if (rand == 0) {
                         player1Cards[player1CardCount] = gameState.playerStates[i].cardsInDeck[j];
                         player1CardCount++;
                      } else {
                         player2Cards[player2CardCount] = gameState.playerStates[i].cardsInDeck[j];
                         player2CardCount++;
                      }
                  }

                  changes.changePlayerCardsInDeck(Player(i), newCards, cardCount);
              }

              changes.emit();

          }

      }
---

í›Œë¥­í•˜êµ°! ì´ì œ í”Œë ˆì´ì–´ í•œ ëª…ë‹¹ 2ê°œì˜ ë¹„ì–´ìˆëŠ” ìƒˆë¡œìš´ ë±ì„ ì„ ì–¸í–ˆë„¤.

ë‹¤ìŒ ë‹¨ê³„ì—ì„œëŠ” ê° í”Œë ˆì´ì–´ì˜ ì¹´ë“œë¥¼ í•˜ë‚˜ì”© ì‚´í´ë³´ê³ , ë™ì „ ë˜ì§€ê¸°ì²˜ëŸ¼ ë‚œìˆ˜ë¥¼ ìƒ
ì„±í•˜ì—¬ ì–´ë–¤ í”Œë ˆì´ì–´ê°€ ì¹´ë“œë¥¼ ì–»ì„ì§€ ê²°ì •í• ê±¸ì„¸.

ì†”ë¦¬ë””í‹°ì—ì„œ ëœë¤(pseudorandom) ë™ì „ ë˜ì§€ê¸°ë¥¼ ì—¬ëŸ¬ ë²ˆ ì‹¤í–‰í•˜ëŠ” ë°©ë²•ì€ ë‹¤ìŒê³¼ ê°™
ë‹¤ë„¤:

```
uint nonce = 0;
for (uint i = 0; i < 10; i++) {
    // ëì— ìˆëŠ” `% 2`ëŠ” "2ë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€"ë¥¼ ì˜ë¯¸í•˜ê¸° ë•Œë¬¸ì—, `rand`ëŠ” ê²°êµ­
    // `0` ë˜ëŠ” `1`ì´ ë˜ëŠ” ê²ƒì´ì§€.
    uint rand = uint(keccak256(abi.encodePacked(now, nonce))) % 2;

    if (rand == 0) {
      // ë­”ê°€ í•´ë³´ê²Œ.
    } else {
      // ë­”ê°€ ë‹¤ë¥¸ ê²ƒì„ í•´ë³´ê²Œ.
    }

    // ë°˜ë³µë¬¸ì´ ì‹¤í–‰ë  ë•Œë§ˆë‹¤ `rand` ê°’ì´ ë°”ë€Œë„ë¡ nonceë¥¼ í•˜ë‚˜ì”© ì¦ê°€ì‹œì¼œì•¼ í•œë‹¤ë„¤.
    // ê·¸ë ‡ì§€ ì•Šìœ¼ë©´, ë°˜ë³µë¬¸ì´ ëŒ ë•Œ ëœë¤ ê°’ì˜ ê²°ê³¼ê°€ ê°™ì€ ê°’ì´ ë‚˜ì˜¬ ìˆ˜ë„ ìˆë„¤.
    nonce++;
}

```

ë‚œìˆ˜ì— ëŒ€í•œ ë‚´ìš©ì´ ì˜ ìƒê°ë‚˜ì§€ ì•ŠëŠ”ë‹¤ë©´, í¬ë¦½í†  ì¢€ë¹„ ì½”ìŠ¤ 1ì—ì„œ
<a href="https://cryptozombies.io/ko/lesson/4/chapter/4" target=_blank>ë ˆìŠ¨ 4ì˜
ì±•í„° 4</a>ë¥¼ ì°¸ê³ í•˜ê²Œ.

> ì°¸ê³ /ì£¼ì˜: ë‚œìˆ˜ë¥¼ ìƒì„±í•˜ëŠ” ë°©ë²•ì€ ë„ë°•ì„± ê²Œì„ì—ì„œëŠ” ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤ë„¤. ë¸”ë¡ ìƒ
> ì‚°ìë“¤ì´ ì‹œìŠ¤í…œì—ì„œ ìì‹ ë“¤ì´ í¬ê²Œ ì´ê¸°ì§€ ì•ŠëŠ” í•œ íŠ¸ëœì­ì…˜ì„ ë°œí–‰í•˜ì§€ ì•Šë„ë¡ í•
> ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ì§€. í•˜ì§€ë§Œ, ìš°ë¦¬ê°€ í•˜ëŠ” ê²ƒê³¼ ê°™ì´ ê°„ë‹¨í•˜ê²Œ ë±ì„ ì„ëŠ” ì •ë„ë¡œëŠ” ê´œ
> ì°®ë‹¤ë„¤.

## ì§ì ‘ í•´ë³´ê¸°

1. ë¨¼ì €, ìš°ë¦¬ê°€ **Singleton**ì— êµ¬í˜„í•œ `for` ë°˜ë³µë¬¸ ì•ˆì˜ ë‚´ìš©ì„ ì „ë¶€ ì§€ìš°ê²Œ. ì—¬
   ê¸°ì— ìš°ë¦¬ë§Œì˜ ë¡œì§ì„ ë„£ì„ ê±¸ì„¸.

2. ì²« ë²ˆì§¸ ë‹¨ê³„ëŠ” ìš°ë¦¬ê°€ ìœ„ì—ì„œ í•œ ê²ƒì²˜ëŸ¼, 0 ë˜ëŠ” 1ì˜ ê°’ì„ ê°€ì§€ëŠ” `rand`ë¼ëŠ” ì´
   ë¦„ì˜ ëœë¤ `uint` ë³€ìˆ˜ë¥¼ ë§Œë“œëŠ” ê±¸ì„¸. í•˜ì§€ë§Œ, ìœ„ì˜ ì˜ˆì œì˜ `nonce` ëŒ€ì‹ , ìš°ë¦¬ëŠ”
   `player1CardCount + player2CardCount`ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤ë„¤ â€”Â ì´ ë‘ ê°’ ì¤‘ í•˜ë‚˜ê°€
   `for` ë°˜ë³µë¬¸ì´ ì‹¤í–‰ë  ë•Œë§ˆë‹¤ í•˜ë‚˜ì”© ì¦ê°€í•˜ë¦¬ë¼ëŠ” ê²ƒì„ ì•Œê¸° ë•Œë¬¸ì´ì§€.

3. ì´ì œ ë‚œìˆ˜ë¥¼ ìƒì„±í–ˆìœ¼ë‹ˆ, í”Œë ˆì´ì–´ì˜ ë± ì¤‘ í•˜ë‚˜ì— ì¹´ë“œë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆë„¤.

a. `rand`ì˜ ê°’ì´ `0`ì¸ì§€ í™•ì¸í•˜ëŠ” `if` / `else` êµ¬ë¬¸ì„ ë§Œë“¤ê²Œ.

b. ì°¸ì¼ ê²½ìš°, í”Œë ˆì´ì–´ 1ì˜ ë±ì— ì¹´ë“œë¥¼ ì¶”ê°€í•  ê²ƒì´ë„¤. if êµ¬ë¬¸ ì•ˆì—
`player1Cards[player1CardCount]`ì— `gameState.playerStates[i].cardsInDeck[j]`ë¥¼
ëŒ€ì…í•˜ëŠ” ì½”ë“œë¥¼ ì‘ì„±í•˜ê²Œ.

c. ê·¸ë¦¬ê³ , `if` êµ¬ë¬¸ ì•ˆì—ì„œ `player1CardCount++`ë¥¼ ì´ìš©í•´ `player1CardCount`ë¥¼
í•˜ë‚˜ì”© ì¦ê°€ì‹œí‚¤ê²Œ.

d. `else` êµ¬ë¬¸ ì•ˆì—ì„œëŠ” ë°˜ëŒ€ ì‘ì—…ì„ í•˜ë©´ ëœë‹¤ë„¤: **í”Œë ˆì´ì–´ 2**ì˜ ë±ì— ì¹´ë“œë¥¼ ì¶”
ê°€í•˜ê³  `player2CardCount` ê°’ì„ í•˜ë‚˜ì”© ì¦ê°€ì‹œí‚¤ê²Œ.
