---
title: ãƒãƒ«ãƒãƒ•ã‚¡ãƒ³ã‚¸ãƒ–ãƒ«ãƒˆãƒ¼ã‚¯ãƒ³ã®ä¾›çµ¦é‡
actions: ["ç­”ãˆåˆã‚ã›", "ãƒ’ãƒ³ãƒˆ"]
requireLogin: true
material:
  editor:
    language: sol
    startingCode:
      "ZombieCard.sol": |
        pragma solidity ^0.4.25;

        import "./ERC721XToken.sol";

        contract ZombieCard is ERC721XToken {

            // 1. ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ã“ã“ã«ä½œæˆã™ã‚‹ã®ã

            function name() external view returns (string) {
                return "ZombieCard";
            }

            function symbol() external view returns (string) {
                return "ZCX";
            }

            // 2.ã“ã“ã«é–¢æ•°ã‚’å®šç¾©ã™ã‚‹ã®ã

        }
      "ERC721XToken.sol": |

        // Full implementation with all included files at https://github.com/loomnetwork/erc721x

        pragma solidity ^0.4.25;

        import "./../../Interfaces/ERC721X.sol";

        import "./../../Interfaces/ERC721XReceiver.sol";
        import "./ERC721XTokenNFT.sol";

        import "openzeppelin-solidity/contracts/AddressUtils.sol";
        import "./../../Libraries/ObjectsLib.sol";


        // Additional features over NFT token that is compatible with batch transfers
        contract ERC721XToken is ERC721X, ERC721XTokenNFT {

            using ObjectLib for ObjectLib.Operations;
            using AddressUtils for address;

            bytes4 internal constant ERC721X_RECEIVED = 0x660b3370;
            bytes4 internal constant ERC721X_BATCH_RECEIVE_SIG = 0xe9e5be6a;

            event BatchTransfer(address from, address to, uint256[] tokenTypes, uint256[] amounts);


            modifier isOperatorOrOwner(address _from) {
                require((msg.sender == _from) || operators[_from][msg.sender], "msg.sender is neither _from nor operator");
                _;
            }

            function implementsERC721X() public pure returns (bool) {
                return true;
            }

            /**
             * @dev transfer objects from different tokenIds to specified address
             * @param _from The address to BatchTransfer objects from.
             * @param _to The address to batchTransfer objects to.
             * @param _tokenIds Array of tokenIds to update balance of
             * @param _amounts Array of amount of object per type to be transferred.
             * Note:  Arrays should be sorted so that all tokenIds in a same bin are adjacent (more efficient).
             */
            function _batchTransferFrom(address _from, address _to, uint256[] _tokenIds, uint256[] _amounts)
                internal
                isOperatorOrOwner(_from)
            {

                // Requirements
                require(_tokenIds.length == _amounts.length, "Inconsistent array length between args");
                require(_to != address(0), "Invalid recipient");

                if (tokenType[_tokenIds[0]] == NFT) {
                    tokenOwner[_tokenIds[0]] = _to;
                    emit Transfer(_from, _to, _tokenIds[0]);
                }

                // Load first bin and index where the object balance exists
                (uint256 bin, uint256 index) = ObjectLib.getTokenBinIndex(_tokenIds[0]);

                // Balance for current bin in memory (initialized with first transfer)
                // Written with bad library syntax instead of as below to bypass stack limit error
                uint256 balFrom = ObjectLib.updateTokenBalance(
                    packedTokenBalance[_from][bin], index, _amounts[0], ObjectLib.Operations.SUB
                );
                uint256 balTo = ObjectLib.updateTokenBalance(
                    packedTokenBalance[_to][bin], index, _amounts[0], ObjectLib.Operations.ADD
                );

                // Number of transfers to execute
                uint256 nTransfer = _tokenIds.length;

                // Last bin updated
                uint256 lastBin = bin;

                for (uint256 i = 1; i < nTransfer; i++) {
                    // If we're transferring an NFT we additionally should update the tokenOwner and emit the corresponding event
                    if (tokenType[_tokenIds[i]] == NFT) {
                        tokenOwner[_tokenIds[i]] = _to;
                        emit Transfer(_from, _to, _tokenIds[i]);
                    }
                    (bin, index) = _tokenIds[i].getTokenBinIndex();

                    // If new bin
                    if (bin != lastBin) {
                        // Update storage balance of previous bin
                        packedTokenBalance[_from][lastBin] = balFrom;
                        packedTokenBalance[_to][lastBin] = balTo;

                        // Load current bin balance in memory
                        balFrom = packedTokenBalance[_from][bin];
                        balTo = packedTokenBalance[_to][bin];

                        // Bin will be the most recent bin
                        lastBin = bin;
                    }

                    // Update memory balance
                    balFrom = balFrom.updateTokenBalance(index, _amounts[i], ObjectLib.Operations.SUB);
                    balTo = balTo.updateTokenBalance(index, _amounts[i], ObjectLib.Operations.ADD);
                }

                // Update storage of the last bin visited
                packedTokenBalance[_from][bin] = balFrom;
                packedTokenBalance[_to][bin] = balTo;

                // Emit batchTransfer event
                emit BatchTransfer(_from, _to, _tokenIds, _amounts);
            }

            function batchTransferFrom(address _from, address _to, uint256[] _tokenIds, uint256[] _amounts) public {
                // Batch Transfering
                _batchTransferFrom(_from, _to, _tokenIds, _amounts);
            }

            /**
             * @dev transfer objects from different tokenIds to specified address
             * @param _from The address to BatchTransfer objects from.
             * @param _to The address to batchTransfer objects to.
             * @param _tokenIds Array of tokenIds to update balance of
             * @param _amounts Array of amount of object per type to be transferred.
             * @param _data Data to pass to onERC721XReceived() function if recipient is contract
             * Note:  Arrays should be sorted so that all tokenIds in a same bin are adjacent (more efficient).
             */
            function safeBatchTransferFrom(
                address _from,
                address _to,
                uint256[] _tokenIds,
                uint256[] _amounts,
                bytes _data
            )
                public
            {

                // Batch Transfering
                _batchTransferFrom(_from, _to, _tokenIds, _amounts);

                // Pass data if recipient is contract
                if (_to.isContract()) {
                    bytes4 retval = ERC721XReceiver(_to).onERC721XBatchReceived(
                        msg.sender, _from, _tokenIds, _amounts, _data
                    );
                    require(retval == ERC721X_BATCH_RECEIVE_SIG);
                }
            }

            function transfer(address _to, uint256 _tokenId, uint256 _amount) public {
                _transferFrom(msg.sender, _to, _tokenId, _amount);
            }

            function transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public {
                _transferFrom(_from, _to, _tokenId, _amount);
            }

            function _transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount)
                internal
                isOperatorOrOwner(_from)
            {
                require(tokenType[_tokenId] == FT);
                require(_amount <= balanceOf(_from, _tokenId), "Quantity greater than from balance");
                require(_to != address(0), "Invalid to address");

                _updateTokenBalance(_from, _tokenId, _amount, ObjectLib.Operations.SUB);
                _updateTokenBalance(_to, _tokenId, _amount, ObjectLib.Operations.ADD);
                emit TransferWithQuantity(_from, _to, _tokenId, _amount);
            }

            function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public {
                safeTransferFrom(_from, _to, _tokenId, _amount, "");
            }

            function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount, bytes _data) public {
                _transferFrom(_from, _to, _tokenId, _amount);
                require(
                    checkAndCallSafeTransfer(_from, _to, _tokenId, _amount, _data),
                    "Sent to a contract which is not an ERC721X receiver"
                );
            }

            function _mint(uint256 _tokenId, address _to, uint256 _supply) internal {
                // If the token doesn't exist, add it to the tokens array
                if (!exists(_tokenId)) {
                    tokenType[_tokenId] = FT;
                    allTokens.push(_tokenId);
                } else {
                    // if the token exists, it must be a FT
                    require(tokenType[_tokenId] == FT, "Not a FT");
                }

                _updateTokenBalance(_to, _tokenId, _supply, ObjectLib.Operations.ADD);
                emit TransferWithQuantity(address(this), _to, _tokenId, _supply);
            }


            function checkAndCallSafeTransfer(
                address _from,
                address _to,
                uint256 _tokenId,
                uint256 _amount,
                bytes _data
            )
                internal
                returns (bool)
            {
                if (!_to.isContract()) {
                    return true;
                }

                bytes4 retval = ERC721XReceiver(_to).onERC721XReceived(
                    msg.sender, _from, _tokenId, _amount, _data);
                return(retval == ERC721X_RECEIVED);
            }

        }
    answer: >
      pragma solidity ^0.4.25;

      import "./ERC721XToken.sol";

      contract ZombieCard is ERC721XToken {

          mapping(uint => uint) internal tokenIdToIndividualSupply;

          function name() external view returns (string) {
              return "ZombieCard";
          }

          function symbol() external view returns (string) {
              return "ZCX";
          }

          function individualSupply(uint _tokenId) public view returns (uint) {
              return tokenIdToIndividualSupply(_tokenId);
          }

      }
---

é€šå¸¸ã® ERC20 ã‚„ ERC721 ãƒˆãƒ¼ã‚¯ãƒ³ã«ã¯ã€ **_ãƒˆãƒ¼ã‚¯ãƒ³ã‚µãƒ—ãƒ©ã‚¤_** ã¨ã„ã†æ¦‚å¿µãŒã‚ã‚‹ã€‚
ã“ã‚Œã¯ãã®ãƒˆãƒ¼ã‚¯ãƒ³ãŒåˆè¨ˆã©ã®ãã‚‰ã„ã®é‡å­˜åœ¨ã™ã‚‹ã‹ã¨ã„ã†ã‚‚ã®ã ã€‚

ERC721x ã®ãƒãƒ«ãƒãƒ•ã‚¡ãƒ³ã‚¸ãƒ–ãƒ«ãƒˆãƒ¼ã‚¯ãƒ³ã§ã¯ã€åŒã˜ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ä¸­ã«è¤‡æ•°ã®ãƒˆãƒ¼ã‚¯ãƒ³ãŒ
ã‚ã‚‹ã“ã¨ã«ãªã‚‹ â€”Â  ãã—ã¦ãã‚Œãã‚Œã«å›ºæœ‰ã®ã€Œã‚µãƒ—ãƒ©ã‚¤(å­˜åœ¨ã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡)ã€ã‚’æŒ
ã¤ã®ã ã€‚

ã—ã‹ã—ã‚²ãƒ¼ãƒ ã‚¢ã‚¤ãƒ†ãƒ ã®å ´åˆã¯ã€ **ç„¡é™ã«ä¾›çµ¦** ã—ãŸã„ã‚¢ã‚¤ãƒ†ãƒ ã‚‚ã‚ã‚‹ã¯ãšã ã€‚ãã†ã—
ãªã„ã¨ä¾‹ãˆã°ã‚²ãƒ¼ãƒ ã« 1000 æœ¬ã®å‰£ã—ã‹ãªã‘ã‚Œã°ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ 1000 äººã«é™å®šã—ãªã„ã¨
ã„ã‘ãªããªã‚‹ã‹ã€ã‚‚ã—ãã¯å¾Œã‹ã‚‰ã‚²ãƒ¼ãƒ ã«å‚åŠ ã—ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã¨ã£ã¦ã‚ã¾ã‚Šé¢ç™½ããªã„
ã‚‚ã®ã«ãªã£ã¦ã—ã¾ã†ã‹ã‚‰ãªï¼

Zombie Battleground ã§ã¯ã€ï¼’ã¤ã®ç•°ãªã‚‹ã‚¿ã‚¤ãƒ—ã®ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚‹ â€” ä¾›çµ¦é‡ãŒå›ºå®šã•ã‚ŒãŸ
ã‚«ãƒ¼ãƒ‰ã¨ã€ç„¡é™ã«ä¾›çµ¦ã•ã‚Œã‚‹ã‚«ãƒ¼ãƒ‰ã ã€‚

- _ã‚¹ã‚¿ãƒ³ãƒ€ãƒ¼ãƒ‰ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰_: å…¸å‹çš„ãªã‚²ãƒ¼ãƒ ã‚¢ã‚¤ãƒ†ãƒ ã®ã‚ˆã†ã«ã€ä¾›çµ¦é‡ã«åˆ¶é™
  ã¯ãªã„ â€” ã“ã®ãŸã‚å¤šãã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ¬¡ã€…ã¨ã‚²ãƒ¼ãƒ ã«å‚åŠ ã—ç¶šã‘ã‚‹ã“ã¨ãŒã§ãã€å…¨å“¡
  ãŒã“ã®ã‚«ãƒ¼ãƒ‰ã‚’å…¥æ‰‹ã—ç«¶äº‰åŠ›ã®é«˜ã„ãƒ‡ãƒƒã‚­ã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã¨ãªã‚‹ã€‚çµŒæ¸ˆç”¨èªã§è¨€
  ã†æ‰€ã®ã€Œã‚¤ãƒ³ãƒ•ãƒ¬ã€ã®ã‚«ãƒ¼ãƒ‰ã ã¨ã—ã‚ˆã†ã€‚

- _ãƒªãƒŸãƒ†ãƒƒãƒ‰ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰_. ã“ã‚Œã‚‰ã¯ã‚¹ã‚¿ãƒ³ãƒ€ãƒ¼ãƒ‰ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰ã®å¤–è¦³ä¸Š
  ã®å¤‰ç¨®ã§ã‚ã‚Šã€ä¾›çµ¦é‡ã¯å›ºå®šã•ã‚Œã¦ã„ã‚‹ã€‚ã‚¹ã‚¿ãƒ³ãƒ€ãƒ¼ãƒ‰ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ã‚ˆã‚Šã‚‚ã‚«ãƒƒã‚³ã„ã„
  å¸Œå°‘ãªã‚³ãƒ¬ã‚¯ã‚¿ãƒ¼ã‚ºã‚¢ã‚¤ãƒ†ãƒ ãªã®ã ã€‚æã‚‰ãå…¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®é–“ã§ã‚‚æ•°ç™¾æšã—ã‹å­˜åœ¨ã—ãªã„
  ã®ã§ã€ãã®å¸Œå°‘æ€§ãŒä¾¡å€¤ã‚’é«˜ã‚ã¦ã„ã‚‹ã®ã ã€‚

ã“ã®ãƒãƒ£ãƒ—ã‚¿ãƒ¼ã§ã¯ã€ãƒˆãƒ¼ã‚¯ãƒ³ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆå†…ã«ã“ã®ï¼’ã‚¿ã‚¤ãƒ—ã®ã‚«ãƒ¼ãƒ‰ã‚’å®Ÿè£…ã™ã‚‹æ–¹æ³•ã‚’
ã‚„ã£ã¦ã„ãã‹ã‚‰ãªã€‚

## å®Ÿè£…

åˆ†ã‹ã£ã¦ã„ã‚‹ã ã‚ã†ãŒã€ã“ã®ï¼’ã‚¿ã‚¤ãƒ—ã®ã‚«ãƒ¼ãƒ‰ã®ä¸»ãªé•ã„ã¯`totalSupply` â€”Â  ã¤ã¾ã‚Šå­˜
åœ¨ã™ã‚‹ã‚«ãƒ¼ãƒ‰ã®ç·æ•°ã§ã‚ã‚‹ã€‚

ãƒªãƒŸãƒ†ãƒƒãƒ‰ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰ã¯`uint`ã§å›ºå®šæ•°ã®`totalSupply`ã‚’æŒã¡ã€ä¸€æ–¹ã‚¹ã‚¿ãƒ³ãƒ€
ãƒ¼ãƒ‰ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰ã¯ç„¡é™ã®`totalSupply`ã‚’æŒã£ã¦ã„ã‚‹ã€‚

ç„¡é™ã¨ã„ã†ã®ã¯ä¾›çµ¦é‡ã«è¨­å®šã§ãã‚‹æ•°å­—ã§ã¯ãªã„ã‹ã‚‰ã€ã‚¹ã‚¿ãƒ³ãƒ€ãƒ¼ãƒ‰ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰
ã«ã¯ãƒ—ãƒ¬ã‚¤ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã¨ã—ã¦`0`ã«è¨­å®šã—ã¦ãŠãã®ã ã€‚å¾Œã‹ã‚‰ã‚³ãƒ¼ãƒ‰ä¸­ã®åˆ¥ã®ã¨ã“ã‚ã§ä¾›
çµ¦é‡ãŒ`0`ã§ã‚ã‚‹ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã€ãã†ã§ã‚ã‚‹å ´åˆã¯ä¾›çµ¦é‡ã«åˆ¶é™ã®ãªã„ã‚¹ã‚¿ãƒ³ãƒ€ãƒ¼ãƒ‰ã‚¨
ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰ã§ã‚ã‚‹ã¨åˆ¤åˆ¥ã§ãã‚‹ã‚ˆã†ã«ãªã€‚

æ¬¡ã®ãƒãƒ£ãƒ—ã‚¿ãƒ¼ã§ã¯ã€ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«æ–°è¦ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆã®é–¢æ•°ã‚’ä½œã£ã¦ã„ã“ã†ã€‚ã ãŒã¾ãš
ã¯ã€å„ã‚«ãƒ¼ãƒ‰ã®`totalSupply`ã‚’è¿½è·¡ã™ã‚‹é–¢æ•°ã‚’è¨­å®šã™ã‚‹ãã€‚

# ã•ã‚ãƒ†ã‚¹ãƒˆã

1. `tokenIdToIndividualSupply`ã¨ã„ã†`mapping`ã‚’ä½œæˆã›ã‚ˆã€‚ã“ã‚Œã¯`uint`â†’`uint`ã«ãƒ
   ãƒƒãƒ—ã—ã€`internal`ã§ã‚ã‚‹ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã€‚

2. `individualSupply`ã¨ã„ã†`function`ã‚’ä½œæˆã—ã€`public view`ã¨ã›ã‚ˆã€‚ã•ã‚‰ã«ã‚¤ãƒ³ãƒ—
   ãƒƒãƒˆã¨ã—ã¦`uint _tokenId`ã‚’å—ã‘å–ã‚Šã€`uint`ã‚’`returns`ã™ã‚‹ã“ã¨ã€‚

3. é–¢æ•°æœ¬æ–‡ã¯ã€ã‚·ãƒ³ãƒ—ãƒ«ã«`return tokenIdToIndividualSupply(_tokenId)`ã¨ã—ã¦ãŠã‘
   ã€‚
