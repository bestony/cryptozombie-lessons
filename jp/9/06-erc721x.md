---
title: „Ç´„Éº„ÉâÁîüÊàê„ÅÆÁ∂ö„Åç
actions: ["Á≠î„ÅàÂêà„Çè„Åõ", "„Éí„É≥„Éà"]
requireLogin: true
material:
  editor:
    language: sol
    startingCode:
      "ZombieCard.sol": |
        pragma solidity ^0.4.25;

        import "./ERC721XToken.sol";
        import "./Ownable.sol";

        contract ZombieCard is ERC721XToken {

            mapping(uint => uint) internal tokenIdToIndividualSupply;

            event TokenAwarded(uint indexed tokenId, address claimer, uint amount);

            function name() external view returns (string) {
                return "ZombieCard";
            }

            function symbol() external view returns (string) {
                return "ZCX";
            }

            function individualSupply(uint _tokenId) public view returns (uint) {
                return tokenIdToIndividualSupply(_tokenId);
            }

          function mintToken(uint _tokenId, uint _supply) public onlyOwner {
              require(!exists(_tokenId), "Error: Tried to mint duplicate token id");
              _mint(_tokenId, msg.sender, _supply);
              tokenIdToIndividualSupply[_tokenId] = _supply;
          }

            function awardToken(uint _tokenId, address _to, uint _amount) public onlyOwner {
                require(exists(_tokenId), "TokenID has not been minted");
                // „Åì„Åì„Åã„ÇâÂßã„ÇÅ„Çà
            }

        }
      "ERC721XToken.sol": |

        // Full implementation with all included files at https://github.com/loomnetwork/erc721x

        pragma solidity ^0.4.25;

        import "./../../Interfaces/ERC721X.sol";

        import "./../../Interfaces/ERC721XReceiver.sol";
        import "./ERC721XTokenNFT.sol";

        import "openzeppelin-solidity/contracts/AddressUtils.sol";
        import "./../../Libraries/ObjectsLib.sol";


        // Additional features over NFT token that is compatible with batch transfers
        contract ERC721XToken is ERC721X, ERC721XTokenNFT {

            using ObjectLib for ObjectLib.Operations;
            using AddressUtils for address;

            bytes4 internal constant ERC721X_RECEIVED = 0x660b3370;
            bytes4 internal constant ERC721X_BATCH_RECEIVE_SIG = 0xe9e5be6a;

            event BatchTransfer(address from, address to, uint256[] tokenTypes, uint256[] amounts);


            modifier isOperatorOrOwner(address _from) {
                require((msg.sender == _from) || operators[_from][msg.sender], "msg.sender is neither _from nor operator");
                _;
            }

            function implementsERC721X() public pure returns (bool) {
                return true;
            }

            /**
             * @dev transfer objects from different tokenIds to specified address
             * @param _from The address to BatchTransfer objects from.
             * @param _to The address to batchTransfer objects to.
             * @param _tokenIds Array of tokenIds to update balance of
             * @param _amounts Array of amount of object per type to be transferred.
             * Note:  Arrays should be sorted so that all tokenIds in a same bin are adjacent (more efficient).
             */
            function _batchTransferFrom(address _from, address _to, uint256[] _tokenIds, uint256[] _amounts)
                internal
                isOperatorOrOwner(_from)
            {

                // Requirements
                require(_tokenIds.length == _amounts.length, "Inconsistent array length between args");
                require(_to != address(0), "Invalid recipient");

                if (tokenType[_tokenIds[0]] == NFT) {
                    tokenOwner[_tokenIds[0]] = _to;
                    emit Transfer(_from, _to, _tokenIds[0]);
                }

                // Load first bin and index where the object balance exists
                (uint256 bin, uint256 index) = ObjectLib.getTokenBinIndex(_tokenIds[0]);

                // Balance for current bin in memory (initialized with first transfer)
                // Written with bad library syntax instead of as below to bypass stack limit error
                uint256 balFrom = ObjectLib.updateTokenBalance(
                    packedTokenBalance[_from][bin], index, _amounts[0], ObjectLib.Operations.SUB
                );
                uint256 balTo = ObjectLib.updateTokenBalance(
                    packedTokenBalance[_to][bin], index, _amounts[0], ObjectLib.Operations.ADD
                );

                // Number of transfers to execute
                uint256 nTransfer = _tokenIds.length;

                // Last bin updated
                uint256 lastBin = bin;

                for (uint256 i = 1; i < nTransfer; i++) {
                    // If we're transferring an NFT we additionally should update the tokenOwner and emit the corresponding event
                    if (tokenType[_tokenIds[i]] == NFT) {
                        tokenOwner[_tokenIds[i]] = _to;
                        emit Transfer(_from, _to, _tokenIds[i]);
                    }
                    (bin, index) = _tokenIds[i].getTokenBinIndex();

                    // If new bin
                    if (bin != lastBin) {
                        // Update storage balance of previous bin
                        packedTokenBalance[_from][lastBin] = balFrom;
                        packedTokenBalance[_to][lastBin] = balTo;

                        // Load current bin balance in memory
                        balFrom = packedTokenBalance[_from][bin];
                        balTo = packedTokenBalance[_to][bin];

                        // Bin will be the most recent bin
                        lastBin = bin;
                    }

                    // Update memory balance
                    balFrom = balFrom.updateTokenBalance(index, _amounts[i], ObjectLib.Operations.SUB);
                    balTo = balTo.updateTokenBalance(index, _amounts[i], ObjectLib.Operations.ADD);
                }

                // Update storage of the last bin visited
                packedTokenBalance[_from][bin] = balFrom;
                packedTokenBalance[_to][bin] = balTo;

                // Emit batchTransfer event
                emit BatchTransfer(_from, _to, _tokenIds, _amounts);
            }

            function batchTransferFrom(address _from, address _to, uint256[] _tokenIds, uint256[] _amounts) public {
                // Batch Transfering
                _batchTransferFrom(_from, _to, _tokenIds, _amounts);
            }

            /**
             * @dev transfer objects from different tokenIds to specified address
             * @param _from The address to BatchTransfer objects from.
             * @param _to The address to batchTransfer objects to.
             * @param _tokenIds Array of tokenIds to update balance of
             * @param _amounts Array of amount of object per type to be transferred.
             * @param _data Data to pass to onERC721XReceived() function if recipient is contract
             * Note:  Arrays should be sorted so that all tokenIds in a same bin are adjacent (more efficient).
             */
            function safeBatchTransferFrom(
                address _from,
                address _to,
                uint256[] _tokenIds,
                uint256[] _amounts,
                bytes _data
            )
                public
            {

                // Batch Transfering
                _batchTransferFrom(_from, _to, _tokenIds, _amounts);

                // Pass data if recipient is contract
                if (_to.isContract()) {
                    bytes4 retval = ERC721XReceiver(_to).onERC721XBatchReceived(
                        msg.sender, _from, _tokenIds, _amounts, _data
                    );
                    require(retval == ERC721X_BATCH_RECEIVE_SIG);
                }
            }

            function transfer(address _to, uint256 _tokenId, uint256 _amount) public {
                _transferFrom(msg.sender, _to, _tokenId, _amount);
            }

            function transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public {
                _transferFrom(_from, _to, _tokenId, _amount);
            }

            function _transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount)
                internal
                isOperatorOrOwner(_from)
            {
                require(tokenType[_tokenId] == FT);
                require(_amount <= balanceOf(msg.sender, _tokenId), "Quantity greater than from balance");
                require(_to != address(0), "Invalid to address");

                _updateTokenBalance(_from, _tokenId, _amount, ObjectLib.Operations.SUB);
                _updateTokenBalance(_to, _tokenId, _amount, ObjectLib.Operations.ADD);
                emit TransferWithQuantity(_from, _to, _tokenId, _amount);
            }

            function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public {
                safeTransferFrom(_from, _to, _tokenId, _amount, "");
            }

            function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount, bytes _data) public {
                _transferFrom(_from, _to, _tokenId, _amount);
                require(
                    checkAndCallSafeTransfer(_from, _to, _tokenId, _amount, _data),
                    "Sent to a contract which is not an ERC721X receiver"
                );
            }

            function _mint(uint256 _tokenId, address _to, uint256 _supply) internal {
                // If the token doesn't exist, add it to the tokens array
                if (!exists(_tokenId)) {
                    tokenType[_tokenId] = FT;
                    allTokens.push(_tokenId);
                } else {
                    // if the token exists, it must be a FT
                    require(tokenType[_tokenId] == FT, "Not a FT");
                }

                _updateTokenBalance(_to, _tokenId, _supply, ObjectLib.Operations.ADD);
                emit TransferWithQuantity(address(this), _to, _tokenId, _supply);
            }


            function checkAndCallSafeTransfer(
                address _from,
                address _to,
                uint256 _tokenId,
                uint256 _amount,
                bytes _data
            )
                internal
                returns (bool)
            {
                if (!_to.isContract()) {
                    return true;
                }

                bytes4 retval = ERC721XReceiver(_to).onERC721XReceived(
                    msg.sender, _from, _tokenId, _amount, _data);
                return(retval == ERC721X_RECEIVED);
            }

        }
    answer: >
      pragma solidity ^0.4.25;

      import "./ERC721XToken.sol"; import "./Ownable.sol";

      contract ZombieCard is ERC721XToken {

          mapping(uint => uint) internal tokenIdToIndividualSupply;

          event TokenAwarded(uint indexed tokenId, address claimer, uint
      amount);

          function name() external view returns (string) {
              return "ZombieCard";
          }

          function symbol() external view returns (string) {
              return "ZCX";
          }

          function individualSupply(uint _tokenId) public view returns (uint) {
              return tokenIdToIndividualSupply(_tokenId);
          }

          function mintToken(uint _tokenId, uint _supply) public onlyOwner {
              require(!exists(_tokenId), "Error: Tried to mint duplicate token
      id");
              _mint(_tokenId, msg.sender, _supply);
              tokenIdToIndividualSupply[_tokenId] = _supply;
          }

          function awardToken(uint _tokenId, address _to, uint _amount) public
      onlyOwner {
              require(exists(_tokenId), "TokenID has not been minted");
              if (individualSupply(_tokenId) > 0) {
                  require(_amount <= balanceOf(msg.sender, _tokenId), "Quantity
      greater than remaining cards");
                  _updateTokenBalance(msg.sender, _tokenId, _amount,
      ObjectLib.Operations.SUB);
              }
              _updateTokenBalance(_to, _tokenId, _amount,
      ObjectLib.Operations.ADD);
              emit TokenAwarded(_tokenId, _to, _amount);
          }

      }
---

„Åß„ÅØ`ERC721XToken.sol`„Å´„ÅÇ„Çã‰∏ÄËà¨ÁöÑ„Å™„Éà„É©„É≥„Çπ„Éï„Ç°„ÉºÈñ¢Êï∞„Åß‰Ωï„ÅåËµ∑„Åì„Å£„Å¶„ÅÑ„Çã„Åã„ÇíË¶ã„Å¶
„Åø„Çà„ÅÜ„ÄÇ„É¶„Éº„Ç∂„Éº„Å´„Éà„Éº„ÇØ„É≥„ÇíÁßªËª¢„Åô„Çã„Åü„ÇÅ„Å´`awardToken`„Åß‰Ωï„Çí„Åô„Åπ„Åç„ÅãÁêÜËß£„Åß„Åç„Çã„ÅØ
„Åö„Å†:

### „Éï„Ç°„É≥„Ç∏„Éñ„É´(‰ª£ÊõøÂèØËÉΩ)„Éà„Éº„ÇØ„É≥„ÅÆÁßªËª¢

`ERC721XToken.sol`„Å´„ÅÇ„Çã„Éï„Ç°„É≥„Ç∏„Éñ„É´„Éà„Éº„ÇØ„É≥(FT)Âêë„Åë„ÅÆ„Éà„É©„É≥„Çπ„Éï„Ç°„ÉºÈñ¢Êï∞„ÅÆ„Ç≥„Éº„Éâ
„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Å£„Å¶„ÅÑ„Çã:

```
function _transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount)
    internal
    isOperatorOrOwner(_from)
{
    require(tokenType[_tokenId] == FT);
    require(_amount <= balanceOf(_from, _tokenId), "Quantity greater than from balance");
    require(_to != address(0), "Invalid to address");

    _updateTokenBalance(_from, _tokenId, _amount, ObjectLib.Operations.SUB);
    _updateTokenBalance(_to, _tokenId, _amount, ObjectLib.Operations.ADD);
    emit TransferWithQuantity(_from, _to, _tokenId, _amount);
}
```

Ë¶ã„Å¶„ÅÆÈÄö„Çä„ÄÅ„Åì„ÅÆÈñ¢Êï∞„ÅÆÂ§ßÈÉ®ÂàÜ„ÅØÂçò„Å´ÈÄÅ‰ø°ËÄÖ„ÅÆ„Éà„Éº„ÇØ„É≥ÊÆãÈ´ò„Çí`_amount`ÂàÜÊ∏õ„Çâ„Åó„ÄÅ„Åï„Çâ
„Å´Âèó‰ø°ËÄÖ„ÅÆ„Éà„Éº„ÇØ„É≥ÊÆãÈ´ò„Çí`_amount`ÂàÜÂ¢ó„ÇÑ„Åó„Å¶„ÅÑ„Çã„ÄÇ

„Å†„ÅåÊàë„ÄÖ„Å´„ÅØ„Çπ„Çø„É≥„ÉÄ„Éº„Éâ„Ç®„Éá„Ç£„Ç∑„Éß„É≥„Ç´„Éº„Éâ„ÇÇ„ÅÇ„Çã„Åã„Çâ„ÄÅ`awardToken`Èñ¢Êï∞„ÅÆ„É≠„Ç∏„ÉÉ„ÇØ
„ÅØÂ∞ë„ÅóÁï∞„Å™„Å£„Åü„ÇÇ„ÅÆ„Å´„Å™„Çã„ÅÆ„Å†„ÄÇ

ÁÑ°Èôê„Å´‰æõÁµ¶„Åï„Çå„Çã„Çπ„Çø„É≥„ÉÄ„Éº„Éâ„Ç®„Éá„Ç£„Ç∑„Éß„É≥„Ç´„Éº„Éâ„ÇÇ„ÅÇ„Å£„Åü„Åì„Å®„ÅØË¶ö„Åà„Å¶„ÅÑ„Çã„Å™ÔºüÊàë„ÄÖ„Åå
‰æõÁµ¶Èáè„Çí`0`„Å®„Åó„Å¶‰øùÂ≠ò„Åó„Å¶„Åä„ÅÑ„Åü„ÇÇ„ÅÆ„Å†„Åå„ÄÅ`_amount`„Çí`0`„Åã„ÇâÂ∑Æ„ÅóÂºï„Åè„Åì„Å®„ÅØ„Åó„Åü„Åè
„Å™„ÅÑ„ÄÇ

„Å†„Åã„Çâ„ÄÅ„É™„Éü„ÉÜ„ÉÉ„Éâ„Ç®„Éá„Ç£„Ç∑„Éß„É≥„ÅÆ„Ç´„Éº„Éâ„Åã‰æõÁµ¶Èáè`0`„ÅÆ„Çπ„Çø„É≥„ÉÄ„Éº„Éâ„Ç®„Éá„Ç£„Ç∑„Éß„É≥„ÅÆ„Ç´
„Éº„Éâ„Åã„Çí`awardToken`„ÅÆ„É≠„Ç∏„ÉÉ„ÇØ„Åß„ÉÅ„Çß„ÉÉ„ÇØ„Åó„ÄÅ„É™„Éü„ÉÜ„ÉÉ„Éâ„Ç®„Éá„Ç£„Ç∑„Éß„É≥„Ç´„Éº„Éâ„ÅÆ„Éà„Éº„ÇØ
„É≥ÊÆãÈ´ò„ÅÆ„Åø„ÇíÂ∑Æ„ÅóÂºï„Åã„Å™„Åè„Å¶„ÅØ„Å™„Çâ„Å™„ÅÑ„ÅÆ„Å†„ÄÇ

# „Åï„ÅÇ„ÉÜ„Çπ„Éà„Å

ÂÆüË£Ö„ÅÆÁ∂ö„Åç„Çí„ÇÑ„Å£„Å¶„ÅÑ„Åè„Åû...

1. `if`„Çπ„ÉÜ„Éº„Éà„É°„É≥„Éà„Çí‰ΩúÊàê„Åó„ÄÅ`individualSupply[_tokenId]`„Åå`0`„Çà„ÇäÂ§ß„Åç„ÅÑ„Åã„Çí„ÉÅ
   „Çß„ÉÉ„ÇØ„Åõ„Çà„ÄÇ„Åì„ÅÆÊù°‰ª∂„ÅåÁúü„Åß„ÅÇ„Çå„Å∞„ÄÅ„Åì„ÅÆ„Éà„Éº„ÇØ„É≥„ÅØ‰æõÁµ¶ÈáèÂõ∫ÂÆö„ÅÆ„É™„Éü„ÉÜ„ÉÉ„Éâ„Ç®„Éá„Ç£
   „Ç∑„Éß„É≥„Ç´„Éº„Éâ„Å®„ÅÑ„ÅÜ„Åì„Å®„Å´„Å™„Çã„ÄÇ

2. `if`„Çπ„ÉÜ„Éº„Éà„É°„É≥„Éà„ÅåÁúü„ÅÆÂ†¥Âêà„ÅØ„ÄÅ„Åæ„Åö„É¶„Éº„Ç∂„Éº„Å´ÈÄÅ„Çå„Çã„Å†„Åë„ÅÆÂçÅÂàÜ„Å™„Ç´„Éº„Éâ„Åå„Ç≤„Éº
   „É†„Çµ„Éº„Éê„Éº„Å´„ÅÇ„Çã„Åã„ÇíÁ¢∫Ë™ç„Åó„ÄÅ„Åù„ÅÜ„Åß„Å™„ÅÑÂ†¥Âêà„ÅØ„Ç®„É©„Éº„ÇíÊäï„Åí„Çã„Çà„ÅÜ„Å´„Åó„Åü„ÅÑ„ÄÇ„Åì„ÅÆ
   ÔºëË°å„Åß„ÉÅ„Çß„ÉÉ„ÇØ„ÅåÂèØËÉΩ„Å†:
   `require(_amount <= balanceOf(msg.sender, _tokenId), "Quantity greater than remaining cards");`

3. `if`„Çπ„ÉÜ„Éº„Éà„É°„É≥„Éà„ÅÆÂÜÖÈÉ®„Å´„Å¶„ÄÅ‰ªäÂ∫¶„ÅØ„Ç≤„Éº„É†„Çµ„Éº„Éê„Éº„ÅÆ`_tokenId`ÊÆãÈ´ò
   „Çí`_amount`ÂàÜÊ∏õ„Çâ„Åô„ÅÆ„Å†„ÄÇReference the sample code above in ‰∏ä
   „ÅÆ`_transferFrom()`„Å´„ÅÇ„Çã„Çµ„É≥„Éó„É´„Ç≥„Éº„Éâ„ÇíÂèÇÁÖß„Åó„Å¶„ÄÅ`_updateTokenBalance()`„ÅÆ
   Âëº„Å≥Âá∫„ÅóÊñπ„ÇíË¶ã„Å¶„Åø„Çã„Å®ËâØ„ÅÑ„Åû„ÄÇ

4. `if`„Çπ„ÉÜ„Éº„Éà„É°„É≥„Éà„ÅÆÂæå„Åß„ÄÅ`_to`„Ç¢„Éâ„É¨„Çπ„ÅÆ„Éà„Éº„ÇØ„É≥ÊÆãÈ´ò„Çí`_amount`ÂàÜÂ¢ó„ÇÑ„Åó„Å¶Êõ¥
   Êñ∞„Åó„Åü„ÅÑ„ÄÇ„Åì„Çå„ÅØ`if`„Çπ„ÉÜ„Éº„Éà„É°„É≥„Éà„ÅÆÂ§ñÈÉ®„ÅßË°å„ÅÜ„ÅÆ„Å†„ÄÇ„Å™„Åú„Å™„Çâ„É™„Éü„ÉÜ„ÉÉ„Éâ„Ç®„Éá„Ç£
   „Ç∑„Éß„É≥„Ç´„Éº„Éâ„Å´„ÇÇ„Çπ„Çø„É≥„ÉÄ„Éº„Éâ„Ç®„Éá„Ç£„Ç∑„Éß„É≥„Ç´„Éº„Éâ„Å´„ÇÇÂÆüË°å„Åó„Åü„ÅÑ„Åã„Çâ„Å™„ÄÇ

„Åì„ÅÆÂëº„Å≥Âá∫„ÅóÊñπÊ≥ï„Å´„Å§„ÅÑ„Å¶„ÅØ„ÄÅ‰∏ä„ÅÆ„Çµ„É≥„Éó„É´„Ç≥„Éº„Éâ„ÇíÂèÇÁÖß„Åô„Çã„ÅÆ„Å†„ÄÇ

5. ÊúÄÂæå„Å´„ÄÅ‰ΩúÊàê„Åó„Åü„Ç§„Éô„É≥„Éà„Çí`emit TokenAwarded(_tokenId, _to, _amount);`„ÅßÁô∫ÁÅ´
   „Åó„Åü„ÅÑ„ÄÇ

„Åµ„ÅÖÔºÅ„Åã„Å™„Çä„ÅÆ„Ç≥„Éº„Éâ„ÅÆÂàÜÈáè„Å†„Å£„Åü„Å™„ÄÇ„Åä‰∏ª„ÅåÂÖ®ÈÉ®„Çà„Åè„Åß„Åç„Åü„Åì„Å®„ÇíÈ°ò„Å£„Å¶„ÅÑ„Çã„Åå„ÄÅ„ÇÇ„Åó
ÂÆåÁíß„Å´„Åô„Çã„ÅÆ„ÅåÈõ£„Åó„Åë„Çå„Å∞Ëá™Áî±„Å´„ÄåÁ≠î„ÅàÂêà„Çè„Åõ„Äç„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ËâØ„ÅÑ„Åã„Çâ„Å™ÔºÅ
