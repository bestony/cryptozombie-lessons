---
title: FTã‹ã‚‰NFTã¸ã®å¤‰æ› (ç¶šã)
actions: ["ç­”ãˆåˆã‚ã›", "ãƒ’ãƒ³ãƒˆ"]
requireLogin: true
material:
  editor:
    language: sol
    startingCode:
      "ZombieCard.sol": |
        pragma solidity ^0.4.25;

        import "./ERC721XToken.sol";
        import "./Ownable.sol";

        contract ZombieCard is ERC721XToken {

            mapping(uint => uint) internal tokenIdToIndividualSupply;
            mapping(uint => uint) internal nftTokenIdToMouldId;
            uint nftTokenIdIndex = 1000000;


            event TokenAwarded(uint indexed tokenId, address claimer, uint amount);

            function name() external view returns (string) {
                return "ZombieCard";
            }

            function symbol() external view returns (string) {
                return "ZCX";
            }

            function individualSupply(uint _tokenId) public view returns (uint) {
                return tokenIdToIndividualSupply(_tokenId);
            }

            function mintToken(uint _tokenId, uint _supply) public onlyOwner {
                require(!exists(_tokenId), "Error: Tried to mint duplicate token id");
                _mint(_tokenId, msg.sender, _supply);
                tokenIdToIndividualSupply[_tokenId] = _supply;
            }

            function awardToken(uint _tokenId, address _to, uint _amount) public onlyOwner {
                require(exists(_tokenId), "TokenID has not been minted");
                if (individualSupply(_tokenId) > 0) {
                    require(_amount <= balanceOf(msg.sender, _tokenId), "Quantity greater than from balance");
                    _updateTokenBalance(msg.sender, _tokenId, _amount, ObjectLib.Operations.SUB);
                }
                _updateTokenBalance(_to, _tokenId, _amount, ObjectLib.Operations.ADD);
                emit TokenAwarded(_tokenId, _to, _amount);
            }

            function convertToNFT(uint _tokenId, uint _amount) public {
                require(tokenType[_tokenId] == FT);
                require(_amount <= balanceOf(msg.sender, _tokenId), "You do not own enough tokens");
                // ã“ã“ã‹ã‚‰å§‹ã‚ã‚‹ã®ã
            }

        }
      "ERC721XToken.sol": |

        // Full implementation with all included files at https://github.com/loomnetwork/erc721x

        pragma solidity ^0.4.25;

        import "./../../Interfaces/ERC721X.sol";

        import "./../../Interfaces/ERC721XReceiver.sol";
        import "./ERC721XTokenNFT.sol";

        import "openzeppelin-solidity/contracts/AddressUtils.sol";
        import "./../../Libraries/ObjectsLib.sol";


        // Additional features over NFT token that is compatible with batch transfers
        contract ERC721XToken is ERC721X, ERC721XTokenNFT {

            using ObjectLib for ObjectLib.Operations;
            using AddressUtils for address;

            bytes4 internal constant ERC721X_RECEIVED = 0x660b3370;
            bytes4 internal constant ERC721X_BATCH_RECEIVE_SIG = 0xe9e5be6a;

            event BatchTransfer(address from, address to, uint256[] tokenTypes, uint256[] amounts);


            modifier isOperatorOrOwner(address _from) {
                require((msg.sender == _from) || operators[_from][msg.sender], "msg.sender is neither _from nor operator");
                _;
            }

            function implementsERC721X() public pure returns (bool) {
                return true;
            }

            /**
             * @dev transfer objects from different tokenIds to specified address
             * @param _from The address to BatchTransfer objects from.
             * @param _to The address to batchTransfer objects to.
             * @param _tokenIds Array of tokenIds to update balance of
             * @param _amounts Array of amount of object per type to be transferred.
             * Note:  Arrays should be sorted so that all tokenIds in a same bin are adjacent (more efficient).
             */
            function _batchTransferFrom(address _from, address _to, uint256[] _tokenIds, uint256[] _amounts)
                internal
                isOperatorOrOwner(_from)
            {

                // Requirements
                require(_tokenIds.length == _amounts.length, "Inconsistent array length between args");
                require(_to != address(0), "Invalid recipient");

                if (tokenType[_tokenIds[0]] == NFT) {
                    tokenOwner[_tokenIds[0]] = _to;
                    emit Transfer(_from, _to, _tokenIds[0]);
                }

                // Load first bin and index where the object balance exists
                (uint256 bin, uint256 index) = ObjectLib.getTokenBinIndex(_tokenIds[0]);

                // Balance for current bin in memory (initialized with first transfer)
                // Written with bad library syntax instead of as below to bypass stack limit error
                uint256 balFrom = ObjectLib.updateTokenBalance(
                    packedTokenBalance[_from][bin], index, _amounts[0], ObjectLib.Operations.SUB
                );
                uint256 balTo = ObjectLib.updateTokenBalance(
                    packedTokenBalance[_to][bin], index, _amounts[0], ObjectLib.Operations.ADD
                );

                // Number of transfers to execute
                uint256 nTransfer = _tokenIds.length;

                // Last bin updated
                uint256 lastBin = bin;

                for (uint256 i = 1; i < nTransfer; i++) {
                    // If we're transferring an NFT we additionally should update the tokenOwner and emit the corresponding event
                    if (tokenType[_tokenIds[i]] == NFT) {
                        tokenOwner[_tokenIds[i]] = _to;
                        emit Transfer(_from, _to, _tokenIds[i]);
                    }
                    (bin, index) = _tokenIds[i].getTokenBinIndex();

                    // If new bin
                    if (bin != lastBin) {
                        // Update storage balance of previous bin
                        packedTokenBalance[_from][lastBin] = balFrom;
                        packedTokenBalance[_to][lastBin] = balTo;

                        // Load current bin balance in memory
                        balFrom = packedTokenBalance[_from][bin];
                        balTo = packedTokenBalance[_to][bin];

                        // Bin will be the most recent bin
                        lastBin = bin;
                    }

                    // Update memory balance
                    balFrom = balFrom.updateTokenBalance(index, _amounts[i], ObjectLib.Operations.SUB);
                    balTo = balTo.updateTokenBalance(index, _amounts[i], ObjectLib.Operations.ADD);
                }

                // Update storage of the last bin visited
                packedTokenBalance[_from][bin] = balFrom;
                packedTokenBalance[_to][bin] = balTo;

                // Emit batchTransfer event
                emit BatchTransfer(_from, _to, _tokenIds, _amounts);
            }

            function batchTransferFrom(address _from, address _to, uint256[] _tokenIds, uint256[] _amounts) public {
                // Batch Transfering
                _batchTransferFrom(_from, _to, _tokenIds, _amounts);
            }

            /**
             * @dev transfer objects from different tokenIds to specified address
             * @param _from The address to BatchTransfer objects from.
             * @param _to The address to batchTransfer objects to.
             * @param _tokenIds Array of tokenIds to update balance of
             * @param _amounts Array of amount of object per type to be transferred.
             * @param _data Data to pass to onERC721XReceived() function if recipient is contract
             * Note:  Arrays should be sorted so that all tokenIds in a same bin are adjacent (more efficient).
             */
            function safeBatchTransferFrom(
                address _from,
                address _to,
                uint256[] _tokenIds,
                uint256[] _amounts,
                bytes _data
            )
                public
            {

                // Batch Transfering
                _batchTransferFrom(_from, _to, _tokenIds, _amounts);

                // Pass data if recipient is contract
                if (_to.isContract()) {
                    bytes4 retval = ERC721XReceiver(_to).onERC721XBatchReceived(
                        msg.sender, _from, _tokenIds, _amounts, _data
                    );
                    require(retval == ERC721X_BATCH_RECEIVE_SIG);
                }
            }

            function transfer(address _to, uint256 _tokenId, uint256 _amount) public {
                _transferFrom(msg.sender, _to, _tokenId, _amount);
            }

            function transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public {
                _transferFrom(_from, _to, _tokenId, _amount);
            }

            function _transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount)
                internal
                isOperatorOrOwner(_from)
            {
                require(tokenType[_tokenId] == FT);
                require(_amount <= balanceOf(_from, _tokenId), "Quantity greater than from balance");
                require(_to != address(0), "Invalid to address");

                _updateTokenBalance(_from, _tokenId, _amount, ObjectLib.Operations.SUB);
                _updateTokenBalance(_to, _tokenId, _amount, ObjectLib.Operations.ADD);
                emit TransferWithQuantity(_from, _to, _tokenId, _amount);
            }

            function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public {
                safeTransferFrom(_from, _to, _tokenId, _amount, "");
            }

            function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount, bytes _data) public {
                _transferFrom(_from, _to, _tokenId, _amount);
                require(
                    checkAndCallSafeTransfer(_from, _to, _tokenId, _amount, _data),
                    "Sent to a contract which is not an ERC721X receiver"
                );
            }

            function _mint(uint256 _tokenId, address _to, uint256 _supply) internal {
                // If the token doesn't exist, add it to the tokens array
                if (!exists(_tokenId)) {
                    tokenType[_tokenId] = FT;
                    allTokens.push(_tokenId);
                } else {
                    // if the token exists, it must be a FT
                    require(tokenType[_tokenId] == FT, "Not a FT");
                }

                _updateTokenBalance(_to, _tokenId, _supply, ObjectLib.Operations.ADD);
                emit TransferWithQuantity(address(this), _to, _tokenId, _supply);
            }


            function checkAndCallSafeTransfer(
                address _from,
                address _to,
                uint256 _tokenId,
                uint256 _amount,
                bytes _data
            )
                internal
                returns (bool)
            {
                if (!_to.isContract()) {
                    return true;
                }

                bytes4 retval = ERC721XReceiver(_to).onERC721XReceived(
                    msg.sender, _from, _tokenId, _amount, _data);
                return(retval == ERC721X_RECEIVED);
            }

        }
    answer: >
      pragma solidity ^0.4.25;

      import "./ERC721XToken.sol"; import "./Ownable.sol";

      contract ZombieCard is ERC721XToken {

          mapping(uint => uint) internal tokenIdToIndividualSupply;
          mapping(uint => uint) internal nftTokenIdToMouldId;
          uint nftTokenIdIndex = 1000000;

          event TokenAwarded(uint indexed tokenId, address claimer, uint
      amount);

          function name() external view returns (string) {
              return "ZombieCard";
          }

          function symbol() external view returns (string) {
              return "ZCX";
          }

          function individualSupply(uint _tokenId) public view returns (uint) {
              return tokenIdToIndividualSupply(_tokenId);
          }

          function mintToken(uint _tokenId, uint _supply) public onlyOwner {
              require(!exists(_tokenId), "Error: Tried to mint duplicate token
      id");
              _mint(_tokenId, msg.sender, _supply);
              tokenIdToIndividualSupply[_tokenId] = _supply;
          }

          function awardToken(uint _tokenId, address _to, uint _amount) public
      onlyOwner {
              require(exists(_tokenId), "TokenID has not been minted");
              if (individualSupply(_tokenId) > 0) {
                  require(_amount <= balanceOf(msg.sender, _tokenId), "Quantity
      greater than from balance");
                  _updateTokenBalance(msg.sender, _tokenId, _amount,
      ObjectLib.Operations.SUB);
              }
              _updateTokenBalance(_to, _tokenId, _amount,
      ObjectLib.Operations.ADD);
              emit TokenAwarded(_tokenId, _to, _amount);
          }

          function convertToNFT(uint _tokenId, uint _amount) public {
              require(tokenType[_tokenId] == FT);
              require(_amount <= balanceOf(msg.sender, _tokenId), "You do not
      own enough tokens");
              _updateTokenBalance(msg.sender, _tokenId, _amount,
      ObjectLib.Operations.SUB);
              for (uint i = 0; i < _amount; i++) {
                  _mint(nftTokenIdIndex, msg.sender);
                  nftTokenIdToMouldId[nftTokenIdIndex] = _tokenId;
                  nftTokenIdIndex++;
              }
          }

      }
---

ã§ã¯é–¢æ•°å®Ÿè£…ã®æ®‹ã‚Šã‚’çµ‚ã‚ã‚‰ã›ã‚‹ãï¼

ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå¤‰æ›ã™ã‚‹ã®ã«ååˆ†ãªãƒˆãƒ¼ã‚¯ãƒ³ã‚’æŒã£ã¦ã„ã‚‹ã“ã¨ã‚’æ¤œè¨¼ã§ããŸã‹ã‚‰ã€ä»Šå¾Œã¯å®Ÿéš›
ã«å¤‰æ›ã‚’è¡Œã£ã¦ã¿ã‚‹ã®ã ã€‚

ã“ã®å¤‰æ›ã¯ï¼’ã¤ã®éƒ¨åˆ†ã§è¡Œã£ã¦ã„ãã‹ã‚‰ãª:

1. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®`_tokenId`æ®‹é«˜ã‚’æ¸›ã‚‰ã™(ä»–ã®èª°ã«ç§»è»¢ã™ã‚‹ã‚ã‘ã§ã¯ãªã„ã‹ã‚‰ã€äº‹å®Ÿä¸Šã¯ã
   ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ã€Œç ´å£Šã€ã—ã¦ã„ã‚‹)ã€‚

2. åŒé‡ã® NFT ã‚’ç”Ÿæˆã—ã€åŒã˜ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«å‰²ã‚Šå½“ã¦ã‚‹ã€‚

## NFT ã®ç”Ÿæˆã¨ã¯ï¼Ÿ

ãƒãƒ£ãƒ—ã‚¿ãƒ¼ï¼”ã§ã€ãƒãƒ«ãƒãƒ•ã‚¡ãƒ³ã‚¸ãƒ–ãƒ«ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã«`_mint()`é–¢æ•°ã‚’å‘¼ã³å‡º
ã—ãŸã“ã¨ã‚’æ€ã„å‡ºã™ã®ã ã€‚

ERC721XToken.sol ã«ã¯ã€`_mint()`é–¢æ•°ã®ã‚³ãƒ”ãƒ¼ãŒï¼’ã¤ã‚ã‚‹ã‚“ã ã£ãŸãª:

```
// FTã®ãŸã‚ã®_mint;
function _mint(uint256 _tokenId, address _to, uint256 _supply) internal;

// NFTã®ãŸã‚ã®_mint;
function _mint(uint256 _tokenId, address _to) internal;
```

è¦‹ã¦ã®é€šã‚Šã€å¼•æ•°`_supply`ã‚’ï¼‘ã¤ã¯å—ã‘å–ã‚Šã€ã‚‚ã†ï¼‘ã¤ã¯å—ã‘å–ã£ã¦ã„ãªã„ã®ãŒé•ã„ã¨
ãªã£ã¦ã„ã‚‹ã€‚

Solidity ã§ã¯ã“ã®ã‚ˆã†ã«ã€é–¢æ•°ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’è¤‡æ•°ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã—ã¦ã€ç•°ãªã‚‹æ•°ã®å¼•
æ•°ã‚’å—ã‘å–ã‚‹ã‚ˆã†ã«ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã ã€‚

ã“ã®ãŸã‚`ERC721XToken.sol`ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«ã‚ã‚‹å…¨ã¦ã®å˜ä¸€ã®é–¢æ•°ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã™ã‚‹
ã“ã¨ãŒå¯èƒ½ã ã‹ã‚‰ã€ãã“ã§ã¯ NT ã¨ NFT ã®ä¸¡æ–¹ã«ä½œç”¨ã™ã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒã‚ã‚‹ â€”Â  ã ã‹ã‚‰
å¾“æ¥ã® ERC721 ã‚µãƒ¼ãƒ“ã‚¹ã¨ã®å¾Œæ–¹äº’æ›æ€§ãŒå¯èƒ½ã«ãªã£ã¦ã„ã‚‹ã®ã ã€‚

ã¤ã¾ã‚Šã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã“ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ NFT ã«å¤‰æ›ã—ãŸå¾Œã‚‚ã€ã“ã‚Œã‚‰ã®
NFT ã¯å¾“æ¥ã® ERC721 ã‚µãƒ¼ãƒ“ã‚¹å…¨ã¦ã§åˆ©ç”¨å¯èƒ½ã¨ã„ã†ã“ã¨ã«ãªã‚‹ã‹ã‚‰ãªã€‚

# ã•ã‚ãƒ†ã‚¹ãƒˆã

é–¢æ•°ã®å®Ÿè£…ã‚’å®Œäº†ã•ã›ã‚ˆã†ã€‚

1. æœ€åˆã«`_updateTokenBalance`ã‚’å‘¼ã³å‡ºã—ã€`_tokenId`ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æ®‹é«˜ã‹
   ã‚‰`_amount`åˆ†ã‚’å·®ã—å¼•ãã®ã ã€‚`awardToken()`ã§ä½¿ã£ãŸã®ã¨åŒã˜ã‚³ãƒ¼ãƒ‰ï¼‘è¡Œã‚’ä½¿ã£ã¦
   ã§ãã‚‹ã‹ã‚‰ãªã€‚

2. æ¬¡ã«`for`ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆã—ã€`uint i = 0`ã¨å®£è¨€ã—`i < _amount`ã§ã‚ã‚‹é™ã‚Šãƒ«ãƒ¼ãƒ—ã—
   ç¶šã‘ã‚‹ã‚ˆã†ã«ã›ã‚ˆã€‚

3. `for`ãƒ«ãƒ¼ãƒ—å†…ã§`_mint`é–¢æ•°ã® NFT ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’å‘¼ã³å‡ºã™ã®ã ã€‚æœ€åˆã®å¼•æ•°ã«
   ã¯`nftTokenIdIndex`ã‚’ã€ï¼’ã¤ç›®ã®å¼•æ•°ã«ã¯`msg.sender`ã‚’æ¸¡ã›ã€‚ã“ã‚Œã§ãƒ¦ãƒ‹ãƒ¼ã‚¯ãª
   ID ã‚’æŒã£ãŸ NFT ãŒç”Ÿæˆã•ã‚Œã€åŒã˜ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¸ã¨å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ãªã‚‹ã‹ã‚‰ãªã€‚

4. æ¬¡ã«ã‚«ãƒ¼ãƒ‰ãŒã©ã®å‹ã®ã‚‚ã®ã‹ã‚ã‹ã‚‹ã‚ˆã†ã«ã€ã“ã® NFT ã®å…ƒã€…ã®`_tokenId`ã‚’ä¿å­˜ã™ã‚‹
   ã‚³ãƒ¼ãƒ‰ãŒå¿…è¦ã ã€‚ãã“ã§`nftTokenIdToMouldId`ãƒãƒƒãƒ”ãƒ³ã‚°ã§
   ã€`nftTokenIdIndex`â†’`_tokenId`ã¨ãƒãƒƒãƒ—ã›ã‚ˆã€‚

5. ä»Šåº¦ã¯`nftTokenIdIndex++`ã§ nftTokenIdIndex ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã›ã‚ˆã€‚ã“ã‚Œã§æ¬¡å›
   NFT ã‚’ä½œæˆã™ã‚‹ã¨ãã«ã€ãƒ¦ãƒ‹ãƒ¼ã‚¯ãª ID ã‚’æŒã¤ã“ã¨ã«ãªã‚‹ã€‚

ã•ã‚ãŠçµ‚ã„ã ï¼ã“ã®é–¢æ•°ã¯`_amount`åˆ†ã® FT ã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼æ®‹é«˜ã‹ã‚‰å·®ã—å¼•ãã€åŒæ•°ã® NFT
ã‚’ç”Ÿæˆã—ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«æˆ»ã—ã¦ãã‚Œã‚‹ã‹ã‚‰ãªã€‚

NFT ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®`_mint()`ã‚’å‘¼ã³å‡ºã™å ´åˆã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ–°ãŸã«å—ã‘å–ã£ãŸ NFT ãƒˆãƒ¼ã‚¯
ãƒ³ã® ID ã‚’å–å¾—ã§ãã‚‹ã‚ˆã†ã€ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’é€ä¿¡ã™ã‚‹ã“ã¨ã«ãªã‚‹:
`emit Transfer(address(this), _to, _tokenId)`
