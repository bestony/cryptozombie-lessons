---
title: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‡ãƒƒã‚­ã®å¤‰æ›´
actions: ["ç­”ãˆåˆã‚ã›", "ãƒ’ãƒ³ãƒˆ"]
requireLogin: false
material:
  editor:
    language: solidity
    startingCode:
      "examplegame.sol": |
        pragma solidity 0.4.25;

        import "./ZB/ZBGameMode.sol";

        contract ExampleGame is ZBGameMode  {

            // 1. ã“ã“ã§ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’å®£è¨€ã›ã‚ˆ

            // 2. ã“ã“ã«ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã‚’ä½œæˆã›ã‚ˆ

            function beforeMatchStart(bytes serializedGameState) external {

                GameState memory gameState;
                gameState.init(serializedGameState);

                ZBSerializer.SerializedGameStateChanges memory changes;
                changes.init();

                changes.changePlayerDefense(Player.Player1, 15);
                changes.changePlayerDefense(Player.Player2, 15);
                changes.changePlayerCurrentGooVials(Player.Player1, 3);
                changes.changePlayerCurrentGooVials(Player.Player2, 3);
                changes.changePlayerCurrentGoo(Player.Player1, 3);
                changes.changePlayerCurrentGoo(Player.Player2, 3);
                changes.changePlayerMaxGooVials(Player.Player1, 8);
                changes.changePlayerMaxGooVials(Player.Player2, 8);

            }
        }
      "ZBGameMode.sol": |
        // ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯å‚ç…§ç”¨ã§ã™ãŒã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã«å¿…è¦ãªã‚¤ãƒ³ãƒãƒ¼ãƒˆå…¨ã¦ãŒå«ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚
        // æœ€çµ‚çš„ãªå…¨ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã“ã¡ã‚‰ã«ã‚ã‚Šã¾ã™:
        // https://github.com/loomnetwork/zb_game_mode

        pragma solidity ^0.4.25;

        import "./ZBEnum.sol";
        import "./ZBSerializer.sol";

        contract ZBGameMode {
            using ZBSerializer for ZBSerializer.SerializedGameStateChanges;
            using ZBSerializer for GameState;

            enum Player {
                Player1,
                Player2
            }

            struct PlayerState {
                string id;
                //PlayerActionType currentAction = 2;
                //OverlordInstance overlordInstance = 3;
                CardInstance[] cardsInHand;
                //CardInstance[] CardsInPlay;
                CardInstance[] cardsInDeck;
                Deck deck;
                uint8 defense;
                uint8 currentGoo;
                uint8 gooVials;
                uint32 turnTime;
                //bool hasDrawnCard = 11;
                //repeated CardInstance cardsInGraveyard = 12;
                uint8 initialCardsInHandCount;
                uint8 maxCardsInPlay;
                uint8 maxCardsInHand;
                uint8 maxGooVials;
            }

            struct Deck {
                int64 id;
                string name;
                int64 heroId;
            }

            struct CardInstance {
                int32 instanceId;
                string mouldName;
                int32 defense;
                bool defenseInherited;
                int32 attack;
                bool attackInherited;
                int32 gooCost;
                bool gooCostInherited;
            }

            struct GameState {
                int64 id;
                uint8 currentPlayerIndex;
                PlayerState[] playerStates;
            }

            struct Vector2Int {
                int32 x;
                int32 y;
            }

            struct Rect {
                Vector2Int position;
                Vector2Int size;
            }

            struct CustomUiLabel {
                Rect rect;
                string text;
            }

            struct CustomUiButton {
                Rect rect;
                string title;
                bytes onClickCallData;
            }

            event GameStateChanges (
                bytes serializedChanges
            );

            function getInterfaceVersion() external pure returns (int) {
                return 1;
            }

            function getDataStructureVersion() external pure returns (int) {
                return 1;
            }

            function beforeMatchStart(bytes) external {
            }

            function afterInitialDraw(bytes) external {
            }

            function getCustomUi() external view returns (bytes) {
                return new bytes(0);
            }
        }
      "ZBSerializer.sol": |
        // ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯å‚ç…§ç”¨ã§ã™ãŒã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã«å¿…è¦ãªã‚¤ãƒ³ãƒãƒ¼ãƒˆå…¨ã¦ãŒå«ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚
        // æœ€çµ‚çš„ãªå…¨ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã“ã¡ã‚‰ã«ã‚ã‚Šã¾ã™:
        // https://github.com/loomnetwork/zb_game_mode

        pragma solidity ^0.4.25;

        import "./ZBEnum.sol";
        import "./ZBGameMode.sol";
        import "./SerialityBinaryStream.sol";

        library ZBSerializer {
            using SerialityBinaryStream for SerialityBinaryStream.BinaryStream;
            uint constant defaultSerializedGameStateChangesBufferSize = 512;
            uint constant defaultSerializedCustomUiBufferSize = 512;

            event GameStateChanges (
                bytes serializedChanges
            );

            struct SerializedGameStateChanges {
                SerialityBinaryStream.BinaryStream stream;
            }

            struct SerializedCustomUi {
                SerialityBinaryStream.BinaryStream stream;
            }

            // GameState deserialization

            function init(ZBGameMode.GameState memory self, bytes serializedGameState) internal pure {
                SerialityBinaryStream.BinaryStream memory stream =
                    SerialityBinaryStream.BinaryStream(serializedGameState, serializedGameState.length);

                self.id = stream.readInt64();
                self.currentPlayerIndex = stream.readUint8();

                self.playerStates = new ZBGameMode.PlayerState[](2);
                for (uint i = 0; i < self.playerStates.length; i++) {
                    self.playerStates[i] = deserializePlayerState(stream);
                }
            }

            function deserializePlayerState(SerialityBinaryStream.BinaryStream memory stream) private pure returns (ZBGameMode.PlayerState) {
                ZBGameMode.PlayerState memory player;

                player.id = stream.readString();
                player.deck = deserializeDeck(stream);
                player.cardsInHand = deserializeCardInstanceArray(stream);
                player.cardsInDeck = deserializeCardInstanceArray(stream);
                player.defense = stream.readUint8();
                player.currentGoo = stream.readUint8();
                player.gooVials = stream.readUint8();
                player.turnTime = stream.readUint32();
                player.initialCardsInHandCount = stream.readUint8();
                player.maxCardsInPlay = stream.readUint8();
                player.maxCardsInHand = stream.readUint8();
                player.maxGooVials = stream.readUint8();

                return player;
            }

            function serializeCardInstance(SerialityBinaryStream.BinaryStream memory stream, ZBGameMode.CardInstance card) private pure {
                stream.writeInt32(card.instanceId);
                stream.writeString(card.mouldName);
                stream.writeInt32(card.defense);
                stream.writeBool(card.attackInherited);
                stream.writeInt32(card.attack);
                stream.writeBool(card.defenseInherited);
                stream.writeInt32(card.gooCost);
                stream.writeBool(card.gooCostInherited);
            }

            function deserializeCardInstance(SerialityBinaryStream.BinaryStream memory stream) private pure returns (ZBGameMode.CardInstance) {
                ZBGameMode.CardInstance memory card;

                card.instanceId = stream.readInt32();
                card.mouldName = stream.readString();
                card.defense = stream.readInt32();
                card.defenseInherited = stream.readBool();
                card.attack = stream.readInt32();
                card.attackInherited = stream.readBool();
                card.gooCost = stream.readInt32();
                card.gooCostInherited = stream.readBool();

                return card;
            }

            function serializeCardInstanceArray(SerialityBinaryStream.BinaryStream memory stream, ZBGameMode.CardInstance[] cards) internal pure {
                stream.writeUint32(uint32(cards.length));

                for (uint i = 0; i < cards.length; i++) {
                    serializeCardInstance(stream, cards[i]);
                }
            }

            function deserializeCardInstanceArray(SerialityBinaryStream.BinaryStream memory stream) private pure returns (ZBGameMode.CardInstance[]) {
                uint count = stream.readUint32();

                ZBGameMode.CardInstance[] memory cards = new ZBGameMode.CardInstance[](count);
                for (uint i = 0; i < count; i++) {
                    cards[i] = deserializeCardInstance(stream);
                }

                return cards;
            }

            function deserializeDeck(SerialityBinaryStream.BinaryStream memory stream) private pure returns (ZBGameMode.Deck) {
                ZBGameMode.Deck memory deck;
                deck.id = stream.readInt64();
                deck.name = stream.readString();
                deck.heroId = stream.readInt64();

                return deck;
            }

            function serializeStartGameStateChangeAction(
                SerialityBinaryStream.BinaryStream memory stream,
                ZBEnum.GameStateChangeAction action
                ) private pure {
                stream.writeUint32(uint32(action));
            }

            function serializeStartGameStateChangeAction(
                SerialityBinaryStream.BinaryStream memory stream,
                ZBEnum.GameStateChangeAction action,
                ZBGameMode.Player player
                ) private pure {
                stream.writeUint32(uint32(action));
                stream.writeUint8(uint8(player));
            }

            // CardInstance

            function changeMouldName(ZBGameMode.CardInstance memory self, string mouldName) internal pure {
                self.mouldName = mouldName;
            }

            function changeDefense(ZBGameMode.CardInstance memory self, uint8 defense) internal pure {
                self.defense = defense;
                self.defenseInherited = false;
            }

            function changeAttack(ZBGameMode.CardInstance memory self, uint8 attack) internal pure {
                self.attack = attack;
                self.attackInherited = false;
            }

            function changeGooCost(ZBGameMode.CardInstance memory self, uint8 gooCost) internal pure {
                self.gooCost = gooCost;
                self.gooCostInherited = false;
            }

            // SerializedGameStateChanges

            function init(SerializedGameStateChanges memory self) internal pure {
                init(self, defaultSerializedGameStateChangesBufferSize);
            }

            function init(SerializedGameStateChanges memory self, uint bufferSize) internal pure {
                self.stream = SerialityBinaryStream.BinaryStream(new bytes(bufferSize), bufferSize);
            }

            function getBytes(SerializedGameStateChanges memory self) internal pure returns (bytes) {
                return self.stream.buffer;
            }

            function emit(SerializedGameStateChanges memory self) internal {
                emit GameStateChanges(getBytes(self));
            }

            function changePlayerDefense(SerializedGameStateChanges memory self, ZBGameMode.Player player, uint8 defense) internal pure returns (uint) {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerDefense, player);
                stream.writeUint8(uint8(defense));
            }

            function changePlayerCurrentGoo(SerializedGameStateChanges memory self, ZBGameMode.Player player, uint8 currentGoo) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerCurrentGoo, player);
                stream.writeUint8(uint8(currentGoo));
            }

            function changePlayerCurrentGooVials(SerializedGameStateChanges memory self, ZBGameMode.Player player, uint8 gooVials) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerGooVials, player);
                stream.writeUint8(uint8(gooVials));
            }

            function changePlayerCardsInDeck(
                SerializedGameStateChanges memory self,
                ZBGameMode.Player player,
                ZBGameMode.CardInstance[] cards,
                uint cardCount
                ) internal pure {
                require(
                    cardCount <= cards.length,
                    "cardCount > cards.length"
                );

                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerCardsInDeck, player);
                stream.writeUint32(uint32(cardCount));

                for (uint i = 0; i < cardCount; i++) {
                    serializeCardInstance(stream, cards[i]);
                }
            }

            function changePlayerCardsInDeck(
                SerializedGameStateChanges memory self,
                ZBGameMode.Player player,
                ZBGameMode.CardInstance[] cards
                ) internal pure {
                changePlayerCardsInDeck(self, player, cards, cards.length);
            }

            function changePlayerCardsInHand(
                SerializedGameStateChanges memory self,
                ZBGameMode.Player player,
                ZBGameMode.CardInstance[] cards,
                uint cardCount
                ) internal pure {
                require(
                    cardCount <= cards.length,
                    "cardCount > cards.length"
                );

                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerCardsInHand, player);
                stream.writeUint32(uint32(cardCount));

                for (uint i = 0; i < cardCount; i++) {
                    serializeCardInstance(stream, cards[i]);
                }
            }

            function changePlayerCardsInHand(
                SerializedGameStateChanges memory self,
                ZBGameMode.Player player,
                ZBGameMode.CardInstance[] cards
                ) internal pure {
                changePlayerCardsInHand(self, player, cards, cards.length);
            }

            function changePlayerInitialCardsInHandCount(SerializedGameStateChanges memory self, ZBGameMode.Player player, uint8 count) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerInitialCardsInHandCount, player);
                stream.writeUint8(count);
            }

            function changePlayerMaxCardsInPlay(SerializedGameStateChanges memory self, ZBGameMode.Player player, uint8 count) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerMaxCardsInPlay, player);
                stream.writeUint8(count);
            }

            function changePlayerMaxCardsInHand(SerializedGameStateChanges memory self, ZBGameMode.Player player, uint8 count) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerMaxCardsInHand, player);
                stream.writeUint8(count);
            }

            function changePlayerMaxGooVials(SerializedGameStateChanges memory self, ZBGameMode.Player player, uint8 count) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerMaxGooVials, player);
                stream.writeUint8(count);
            }

            function changePlayerTurnTime(SerializedGameStateChanges memory self, ZBGameMode.Player player, uint32 turnTime) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerTurnTime, player);
                stream.writeUint32(turnTime);
            }

            // SerializedCustomUi

            function init(SerializedCustomUi memory self) internal pure {
                init(self, defaultSerializedCustomUiBufferSize);
            }

            function init(SerializedCustomUi memory self, uint bufferSize) internal pure {
                self.stream = SerialityBinaryStream.BinaryStream(new bytes(bufferSize), bufferSize);
            }

            function getBytes(SerializedCustomUi memory self) internal pure returns (bytes) {
                return self.stream.buffer;
            }

            function add(SerializedCustomUi memory self, ZBGameMode.CustomUiLabel label) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartCustomUiElement(stream, ZBEnum.CustomUiElement.Label, label.rect);
                stream.writeString(label.text);
            }

            function add(SerializedCustomUi memory self, ZBGameMode.CustomUiButton button) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartCustomUiElement(stream, ZBEnum.CustomUiElement.Button, button.rect);
                stream.writeString(button.title);
                stream.writeBytes(button.onClickCallData);
            }

            function serializeStartCustomUiElement(SerialityBinaryStream.BinaryStream memory stream, ZBEnum.CustomUiElement element) private pure {
                stream.writeInt32(int32(element));
            }

            function serializeStartCustomUiElement(
                SerialityBinaryStream.BinaryStream memory stream,
                ZBEnum.CustomUiElement element,
                ZBGameMode.Rect rect
                ) private pure {
                serializeStartCustomUiElement(stream, element);
                serializeRect(stream, rect);
            }

            function serializeRect(SerialityBinaryStream.BinaryStream memory stream, ZBGameMode.Rect rect) private pure {
                serializeVector2Int(stream, rect.position);
                serializeVector2Int(stream, rect.size);
            }

            function serializeVector2Int(SerialityBinaryStream.BinaryStream memory stream, ZBGameMode.Vector2Int v) private pure {
                stream.writeInt32(v.x);
                stream.writeInt32(v.y);
            }
        }
    answer: |
      pragma solidity 0.4.25;

      import "./ZB/ZBGameMode.sol";

      contract ExampleGame is ZBGameMode  {

          mapping (string => bool) internal bannedCards;

          constructor() public {
              // Set rules for which cards are banned from play
              bannedCards["Leash"] = true;
              bannedCards["Bulldozer"] = true;
              bannedCards["Lawnmower"] = true;
              bannedCards["Shopping Cart"] = true;
              bannedCards["Stapler"] = true;
              bannedCards["Nail Bomb"] = true;
              bannedCards["Goo Bottles"] = true;
              bannedCards["Molotov"] = true;
              bannedCards["Super Goo Serum"] = true;
              bannedCards["Junk Spear"] = true;
              bannedCards["Fire Extinguisher"] = true;
              bannedCards["Fresh Meat"] = true;
              bannedCards["Chainsaw"] = true;
              bannedCards["Bat"] = true;
              bannedCards["Whistle"] = true;
              bannedCards["Supply Drop"] = true;
              bannedCards["Goo Beaker"] = true;
              bannedCards["Zed Kit"] = true;
              bannedCards["Torch"] = true;
              bannedCards["Shovel"] = true;
              bannedCards["Boomstick"] = true;
              bannedCards["Tainted Goo"] = true;
              bannedCards["Corrupted Goo"] = true;
          }

          function beforeMatchStart(bytes serializedGameState) external {

              GameState memory gameState;
              gameState.init(serializedGameState);

              ZBSerializer.SerializedGameStateChanges memory changes;
              changes.init();

              // ãƒ™ãƒ¼ã‚¹ã®ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒƒãƒ„ã‚’å¤‰æ›´
              changes.changePlayerDefense(Player.Player1, 15);
              changes.changePlayerDefense(Player.Player2, 15);
              changes.changePlayerCurrentGooVials(Player.Player1, 3);
              changes.changePlayerCurrentGooVials(Player.Player2, 3);
              changes.changePlayerCurrentGoo(Player.Player1, 3);
              changes.changePlayerCurrentGoo(Player.Player2, 3);
              changes.changePlayerMaxGooVials(Player.Player1, 8);
              changes.changePlayerMaxGooVials(Player.Player2, 8);
          }

      }
---

ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ã‚¿ãƒ¼ãƒˆå®ˆå‚™å€¤ã‚„ Goo ãƒœãƒˆãƒ«æ•°ãªã©ã€å¤‰æ•°ã‚’ã†ã¾ãå¤‰æ›´ã§ããŸãªï¼ã ãŒã‚²
ãƒ¼ãƒ å†…ã§å¤‰æ›´ã§ãã‚‹ã®ãŒã“ã‚Œã ã‘ã ã¨ã—ãŸã‚‰ã€ã‚«ã‚¹ã‚¿ãƒ ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã¯ã‹ãªã‚Šåˆ¶é™ã•ã‚Œã¦
ã—ã¾ã†ã ã‚ã†ã€‚

ã“ã®ãƒãƒ£ãƒ—ã‚¿ãƒ¼ã§ã¯ã€ã‚«ã‚¹ã‚¿ãƒ ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã§å¯èƒ½ãªä»–ã®ã“ã¨ã‚’è¦‹ã¦ã„ã“ã†ã€‚ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
ã®ãƒ‡ãƒƒã‚­å†…ã®ã‚«ãƒ¼ãƒ‰ã‚’å¤‰æ›´ã™ã‚‹ã¨ã„ã†ã€è†¨å¤§ãªã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒè¿½åŠ ã•ã‚Œã‚‹ãã€‚

ã“ã‚Œã¯ã€ã©ã®ã‚«ãƒ¼ãƒ‰ãŒã‚«ã‚¹ã‚¿ãƒ ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã§ä½¿ç”¨ã§ãã‚‹ã‹ã‚’åˆ¶é™ã™ã‚‹ã“ã¨(ä¾‹:ã€ŒGoo ã‚³
ã‚¹ãƒˆï¼“ä»¥ä¸‹ã®ã‚«ãƒ¼ãƒ‰ã®ã¿ã€)ã€ã‚‚ã—ãã¯å€‹åˆ¥ã®ã‚«ãƒ¼ãƒ‰ã®ã‚¹ã‚¿ãƒƒãƒ„ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨(ä¾‹:ãŠä¸»
ãŒãƒ‘ãƒ¯ãƒ¼éå‰°/ãƒ‘ãƒ¯ãƒ¼ä¸è¶³ã ã¨æ€ã†ã‚«ãƒ¼ãƒ‰ã®æ”»æ’ƒå€¤ã‚„å®ˆå‚™å€¤ã€Goo ã‚³ã‚¹ãƒˆã‚’å¤‰æ›´)ã€ã“ã®ã©
ã¡ã‚‰ã‹ã®å½¢å¼ã«ãªã‚‹ã€‚

## ç‰¹å®šã®ã‚«ãƒ¼ãƒ‰ã‚’ç¦æ­¢

æˆ‘ã‚‰ãŒ`ExampleGame`ã‚«ã‚¹ã‚¿ãƒ ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰å†…ã§ã€**ã‚¢ã‚¤ãƒ†ãƒ ã®ä½¿ç”¨ã‚’ç¦æ­¢** ã—ãŸã„ã¨ã—
ã‚ˆã†ã€‚

ã“ã‚Œã‚’è¡Œã†æœ€ã‚‚ç°¡å˜ãªæ–¹æ³•ã¯ç¦æ­¢ã—ãŸã„å…¨ã‚«ãƒ¼ãƒ‰ã®ãƒªã‚¹ãƒˆã‚’ä½œã£ã¦ã€å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ‡ãƒƒ
ã‚­ã‚’ãƒ«ãƒ¼ãƒ—ã—ã¦å„ã‚«ãƒ¼ãƒ‰ãŒç¦æ­¢ãƒªã‚¹ãƒˆã«ãªã„ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã€ã‚‚ã—ã‚ã£ãŸå ´åˆã¯ãã®ã‚«ãƒ¼
ãƒ‰ã‚’æ’é™¤ã™ã‚‹ã¨ã„ã†ã‚‚ã®ã ã€‚

> æ³¨: ä»Šå¾Œã‚«ã‚¹ã‚¿ãƒ ãƒ‡ãƒƒã‚­ç·¨é›†ç”»é¢ã‚’è¿½åŠ ã—ã¦ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå‰ã‚‚ã£ã¦ãƒ‡ãƒƒã‚­ã‚’æ§‹ç¯‰ã™ã‚‹éš›
> ã«ã‚ãªãŸã®ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ«ã‚’å®Ÿè¡Œã™ã‚‹ã‚ˆã†ã«ã§ãã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ã—ã‹ã—ã‚«ã‚¹ã‚¿ãƒ ã‚²
> ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã®æ©Ÿèƒ½ã®åˆæœŸæ®µéšã§ã¯ã€ã‚ãªãŸã®ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ«ã‚’å®Ÿè¡Œã™ã‚‹å”¯ä¸€ã®æ–¹æ³•
> ã¯`beforeMatchStart()`ã®ä¸­ã§å®Ÿè¡Œã—ã€ãƒ«ãƒ¼ãƒ«ã§ãƒ—ãƒ¬ã‚¤ã•ã‚Œãªã„ã‚«ãƒ¼ãƒ‰ã¯æ’é™¤ã™ã‚‹ã¨ã„
> ã†ã‚‚ã®ã§ã™ã€‚

## ã•ã‚ãƒ†ã‚¹ãƒˆã

æˆ‘ã‚‰ãŒã‚«ã‚¹ã‚¿ãƒ ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã«ã‚«ãƒ¼ãƒ‰ã®ç¦æ­¢ãƒªã‚¹ãƒˆã‚’åŠ ãˆã¦ã„ã“ã†ã€‚

1. ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆå†’é ­ã§ã€`bannedCards`ã¨ã„ã†`mapping (string => bool)`ã‚’å®£è¨€ã›ã‚ˆã€‚
   ã“ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã¯`internal`å‡ºãªãã¦ã¯ãªã‚‰ãªã„ã€‚

2. ãƒãƒƒãƒ”ãƒ³ã‚°ã®ä¸‹ã«ã€ä»¥ä¸‹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã‚’å®£è¨€ã›ã‚ˆ:

```
constructor() public {

}
```

3. ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã®ä¸­ã§ã€ã©ã®ã‚«ãƒ¼ãƒ‰ãŒç¦æ­¢ã•ã‚Œã¦ã„ã‚‹ã‹ã‚’ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã§å®£è¨€ã›ã‚ˆ:

```
bannedCards["Leash"] = true;
bannedCards["Bulldozer"] = true;
bannedCards["Lawnmower"] = true;
bannedCards["Shopping Cart"] = true;
bannedCards["Stapler"] = true;
bannedCards["Nail Bomb"] = true;
bannedCards["Goo Bottles"] = true;
bannedCards["Molotov"] = true;
bannedCards["Super Goo Serum"] = true;
bannedCards["Junk Spear"] = true;
bannedCards["Fire Extinguisher"] = true;
bannedCards["Fresh Meat"] = true;
bannedCards["Chainsaw"] = true;
bannedCards["Bat"] = true;
bannedCards["Whistle"] = true;
bannedCards["Supply Drop"] = true;
bannedCards["Goo Beaker"] = true;
bannedCards["Zed Kit"] = true;
bannedCards["Torch"] = true;
bannedCards["Shovel"] = true;
bannedCards["Boomstick"] = true;
bannedCards["Tainted Goo"] = true;
bannedCards["Corrupted Goo"] = true;
```

æ¬¡ã®ãƒãƒ£ãƒ—ã‚¿ãƒ¼ã§ã¯å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ‡ãƒƒã‚­ã‚’ãƒ«ãƒ¼ãƒ—ã—ãªãŒã‚‰ã€ã“ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ä½¿ã£ã¦å„
ã‚«ãƒ¼ãƒ‰ãŒç¦æ­¢ã•ã‚Œã¦ã„ãªã„ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ã„ãã‹ã‚‰ãªã€‚

> æ³¨: ä½¿ç”¨ã‚’è¨±å¯ã•ã‚Œã¦ã„ã‚‹ã‚«ãƒ¼ãƒ‰ã‚ˆã‚Šã‚‚ç¦æ­¢ã•ã‚Œã¦ã„ã‚‹ã‚«ãƒ¼ãƒ‰ã®æ–¹ãŒå¤šã„ã»ã©ã«ã‚ãªãŸ
> ã®ãƒ¢ãƒ¼ãƒ‰ãŒãŸãã•ã‚“ã®ã‚«ãƒ¼ãƒ‰ã‚’ç¦æ­¢ã—ã¦ã„ã‚‹å ´åˆã¯ã€`bannedCards`ã§ã¯ãªããƒãƒƒãƒ”ãƒ³
> ã‚°`allowedCards`(è¨±å¯ã•ã‚Œã¦ã„ã‚‹ã‚«ãƒ¼ãƒ‰)ã¨ã™ã‚‹æ–¹ãŒè‰¯ã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚å†…éƒ¨ã®å®Ÿè£…
> ã¯ã‚ãªãŸæ¬¡ç¬¬ã¨ãªã£ã¦ãŠã‚Šã€ã“ã®`mapping`ã¯ã‚„ã‚Šæ–¹ã®ä¸€ä¾‹ã«ã™ãã¾ã›ã‚“ã€‚
