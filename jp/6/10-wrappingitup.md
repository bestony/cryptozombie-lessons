---
title: まとめ
actions: ["答え合わせ", "ヒント"]
requireLogin: true
material:
  saveZombie: false
  zombieDeck:
    zombie:
      lesson: 6
    hideSliders: true
    answer: 1
---

よくやったな！スマートコントラクトとやり取りする、初めての Web3.js を上手に書け
たぞ！

ご褒美として、お主だけの`The Phantom of Web3`ゾンビを与えよう！レベル 3.0(Web3.0
だからな 😉)で、仕上げにキツネのマスク付きだ！右側でチェックするのだ。

## 次のステップ

このレッスンは、あえて基本的なものとした。スマートコントラクトとやりとりするため
に必要なコアロジックを見せたかったが、コードの Web3.js 部分はかなり繰り返しが多
く、完全に実装するのにあまりたくさんの時間を使いたくなかったし、これ以上レッスン
をやって新しい概念を紹介するつもりはない。

だからこの実装は基礎的なものにした。以下は、お主が自分で構築を行う場合にフロント
エンドにゾンビゲームを完全に実装させるための概念のチェックリストだ:

1. `attack`および`changeName`、`changeDna`関数、そして ERC721 の`transfer`、
   `ownerOf`、`balanceOf`関数などの実装。これらの関数の実装は、我々がやった他
   の`send`トランザクションと同じだ。

2. `setKittyContractAddress`や`setLevelUpFee`、さらに`withdraw`を実行できる"管理
   者ページ"の実装。ここでもフロントエンドに特別なロジックはなく、これらの実装は
   すでに説明した関数と同じである。`onlyOwner`修飾子があるので、コントラクトをデ
   プロイしたのと同じ Ethereum アドレスから呼び出したことを確認しなければならな
   いだけだ。

3. アプリに実装したい異なった閲覧ページがいくつかある:

a. 特定のゾンビの情報を閲覧できる、パーマリンク付きの個別のゾンビのページ。この
ページはゾンビの外見を表し、その名前やオーナー(ユーザーのプロフィールページへの
リンク付きで)、また勝敗のカウントやバトル履歴を表示する。

b. パーマリンクでユーザーのゾンビ軍団を見ることができるユーザーページ。個別のゾ
ンビをクリックしてページを表示し、またユーザーが MetaMask にログイン済みでゾンビ
軍隊を所有している場合は、そのクリックすることでそのゾンビを攻撃することになる。

c. 現在のユーザーのゾンビ軍団を表示するホームページ。ユーザーページのバリエーシ
ョンとして（これは我々が index.html で実装を開始したページだ）。

4. ユーザーが CryptoKitties を捕食できるようにする UI のメソッド。ホームページ上
   の各ゾンビに「Feed Me」と表示するボタンをつけ、それをクリックするとユーザーに
   キティの ID を入力するよう要求するテキストボックスを作ればよい(またはキティの
   URL。例:
   <a href="https://www.cryptokitties.co/kitty/578397" target=_blank>https://www.cryptokitties.co/kitty/578397</a>)。
   これで`feedOnKitty`関数のトリガーを引く。

5. 別のユーザーのゾンビを攻撃するための、ユーザー向け UI のメソッド。

この実装方法の 1 つとして、ユーザーが別のユーザーのページを閲覧している時に「こ
のゾンビを攻撃する」ボタンがあるとよい。 ユーザーがボタンをクリックすると、その
ユーザーのゾンビ軍団を含むモーダルがポップアップし「どのゾンビで攻撃しますか？」
と促す。

ユーザーのホームページには、各ゾンビに「ゾンビを攻撃する」というボタンをつけるこ
ともできる。ユーザーがそれをクリックするとモーダルの検索フィールドが表示されるの
で、ゾンビの ID を入力して検索する。または「ランダムなゾンビを攻撃する」というオ
プションで、ランダムな番号を検索する。

またクールダウン期間が経過していないユーザーのゾンビをグレーアウトして、そのゾン
ビではまだ攻撃ができないことと、どれくらい待たなければならないかを UI でユーザー
に示すこともできる。

6. ユーザーのホームページには、ゾンビごとに名前の変更、DNA の変更、レベルアップ
   （有料）のオプションもある。ユーザーがまだ十分なレベルでない場合、オプション
   はグレーアウトされる。

7. 新規ユーザーの場合、最初のゾンビをゾンビ軍団の中に作成するよう促すメッセージ
   を表示し、`createRandomZombie（）`関数を呼び出す必要がある。

8. 最後のチャプターで説明したように、`Attack`イベントと一緒に、ユーザー
   の`address`を`indexed`プロパティとしてスマートコントラクトに追加したい。こう
   してリアルタイム通知をの作成が可能になる　—  ユーザーのゾンビ１体が攻撃された
   ときにポップアップアラートを表示できるので、彼らは攻撃したユーザーやゾンビを
   閲覧して反撃することができる。

9. 同一データへのリクエストで Infura を常に使うわけではないから、ある種のフロン
   トエンドキャッシュレイヤーを実装したい。（現在の`displayZombies`の実装は、イ
   ンターフェースをリフレッシュするたびにゾンビごとに`getZombieDetails`を呼び出
   すが、実際は軍団に追加された新しいゾンビに対してこの関数を呼び出す必要がある
   ）。

10. リアルタイムのチャットルーム。これでゾンビ軍団を倒す時に、所有者のプレーヤー
    たちに話しかけられるぞ？Yes、プリーズ！

これはスタートに過ぎない。これはすでに大きなリストだが、我々はもっと多くの機能を
思いつくはずだ。

HTML、CSS、JavaScript、React や Vue.js のようなフレームワークなど、完全なインタ
ーフェイスを作成していくための多くのフロントエンドコードが存在するから、このフロ
ントエンド全体を構築するのはおそらくそれだけで 10 レッスンのフルコースとなってし
まう。だからかっこよく実装をするのはお主の宿題だ。

> 注: スマートコントラクトは分散されていますが、DApp とやりとりするためのこのフ
> ロントエンドは、どこかの Web サーバーに完全に集約化されます。
>
> しかし
> <a href="https://medium.com/loom-network/loom-network-is-live-scalable-ethereum-dapps-coming-soon-to-a-dappchain-near-you-29d26da00880" target=_blank>Loom
> Network</a>で開発中の SDK を使って、もうすぐ集中化されたウェブサーバーの代わり
> に専用の DApp チェーンからこういったフロントエンドを提供することができるように
> なります。こうしてイーサリアムと Loom DApp チェーン間で、あなたのアプリは 100%
> ブロックチェーン上で動くことになります。

## まとめ

これでレッスン６は終了だ。これでスマートコントラクトと、ユーザーがそれとやり取り
できるフロントエンドをコーディングするのに必要な全スキルが揃ったぞ！

次のレッスンでは、パズルの最後のピース ー イーサリアムへのスマートコントラクトの
デプロイをやっていくからな。

「次のチャプター」をクリックして、ご褒美を申請しよう！
