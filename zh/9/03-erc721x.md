---
title: å¤šé‡åŒè´¨åŒ–ä»£å¸ä¾›åº”é‡
actions: ["checkAnswer", "hints"]
requireLogin: true
material:
  editor:
    language: sol
    startingCode:
      "ZombieCard.sol": |
        pragma solidity ^0.4.25;

        import "./ERC721XToken.sol";

        contract ZombieCard is ERC721XToken {

            // 1. Create mapping here

            function name() external view returns (string) {
                return "ZombieCard";
            }

            function symbol() external view returns (string) {
                return "ZCX";
            }

            // 2. Define function here

        }
      "ERC721XToken.sol": |

        // Full implementation with all included files at https://github.com/loomnetwork/erc721x

        pragma solidity ^0.4.25;

        import "./../../Interfaces/ERC721X.sol";

        import "./../../Interfaces/ERC721XReceiver.sol";
        import "./ERC721XTokenNFT.sol";

        import "openzeppelin-solidity/contracts/AddressUtils.sol";
        import "./../../Libraries/ObjectsLib.sol";


        // Additional features over NFT token that is compatible with batch transfers
        contract ERC721XToken is ERC721X, ERC721XTokenNFT {

            using ObjectLib for ObjectLib.Operations;
            using AddressUtils for address;

            bytes4 internal constant ERC721X_RECEIVED = 0x660b3370;
            bytes4 internal constant ERC721X_BATCH_RECEIVE_SIG = 0xe9e5be6a;

            event BatchTransfer(address from, address to, uint256[] tokenTypes, uint256[] amounts);


            modifier isOperatorOrOwner(address _from) {
                require((msg.sender == _from) || operators[_from][msg.sender], "msg.sender is neither _from nor operator");
                _;
            }

            function implementsERC721X() public pure returns (bool) {
                return true;
            }

            /**
             * @dev transfer objects from different tokenIds to specified address
             * @param _from The address to BatchTransfer objects from.
             * @param _to The address to batchTransfer objects to.
             * @param _tokenIds Array of tokenIds to update balance of
             * @param _amounts Array of amount of object per type to be transferred.
             * Note:  Arrays should be sorted so that all tokenIds in a same bin are adjacent (more efficient).
             */
            function _batchTransferFrom(address _from, address _to, uint256[] _tokenIds, uint256[] _amounts)
                internal
                isOperatorOrOwner(_from)
            {

                // Requirements
                require(_tokenIds.length == _amounts.length, "Inconsistent array length between args");
                require(_to != address(0), "Invalid recipient");

                if (tokenType[_tokenIds[0]] == NFT) {
                    tokenOwner[_tokenIds[0]] = _to;
                    emit Transfer(_from, _to, _tokenIds[0]);
                }

                // Load first bin and index where the object balance exists
                (uint256 bin, uint256 index) = ObjectLib.getTokenBinIndex(_tokenIds[0]);

                // Balance for current bin in memory (initialized with first transfer)
                // Written with bad library syntax instead of as below to bypass stack limit error
                uint256 balFrom = ObjectLib.updateTokenBalance(
                    packedTokenBalance[_from][bin], index, _amounts[0], ObjectLib.Operations.SUB
                );
                uint256 balTo = ObjectLib.updateTokenBalance(
                    packedTokenBalance[_to][bin], index, _amounts[0], ObjectLib.Operations.ADD
                );

                // Number of transfers to execute
                uint256 nTransfer = _tokenIds.length;

                // Last bin updated
                uint256 lastBin = bin;

                for (uint256 i = 1; i < nTransfer; i++) {
                    // If we're transferring an NFT we additionally should update the tokenOwner and emit the corresponding event
                    if (tokenType[_tokenIds[i]] == NFT) {
                        tokenOwner[_tokenIds[i]] = _to;
                        emit Transfer(_from, _to, _tokenIds[i]);
                    }
                    (bin, index) = _tokenIds[i].getTokenBinIndex();

                    // If new bin
                    if (bin != lastBin) {
                        // Update storage balance of previous bin
                        packedTokenBalance[_from][lastBin] = balFrom;
                        packedTokenBalance[_to][lastBin] = balTo;

                        // Load current bin balance in memory
                        balFrom = packedTokenBalance[_from][bin];
                        balTo = packedTokenBalance[_to][bin];

                        // Bin will be the most recent bin
                        lastBin = bin;
                    }

                    // Update memory balance
                    balFrom = balFrom.updateTokenBalance(index, _amounts[i], ObjectLib.Operations.SUB);
                    balTo = balTo.updateTokenBalance(index, _amounts[i], ObjectLib.Operations.ADD);
                }

                // Update storage of the last bin visited
                packedTokenBalance[_from][bin] = balFrom;
                packedTokenBalance[_to][bin] = balTo;

                // Emit batchTransfer event
                emit BatchTransfer(_from, _to, _tokenIds, _amounts);
            }

            function batchTransferFrom(address _from, address _to, uint256[] _tokenIds, uint256[] _amounts) public {
                // Batch Transfering
                _batchTransferFrom(_from, _to, _tokenIds, _amounts);
            }

            /**
             * @dev transfer objects from different tokenIds to specified address
             * @param _from The address to BatchTransfer objects from.
             * @param _to The address to batchTransfer objects to.
             * @param _tokenIds Array of tokenIds to update balance of
             * @param _amounts Array of amount of object per type to be transferred.
             * @param _data Data to pass to onERC721XReceived() function if recipient is contract
             * Note:  Arrays should be sorted so that all tokenIds in a same bin are adjacent (more efficient).
             */
            function safeBatchTransferFrom(
                address _from,
                address _to,
                uint256[] _tokenIds,
                uint256[] _amounts,
                bytes _data
            )
                public
            {

                // Batch Transfering
                _batchTransferFrom(_from, _to, _tokenIds, _amounts);

                // Pass data if recipient is contract
                if (_to.isContract()) {
                    bytes4 retval = ERC721XReceiver(_to).onERC721XBatchReceived(
                        msg.sender, _from, _tokenIds, _amounts, _data
                    );
                    require(retval == ERC721X_BATCH_RECEIVE_SIG);
                }
            }

            function transfer(address _to, uint256 _tokenId, uint256 _amount) public {
                _transferFrom(msg.sender, _to, _tokenId, _amount);
            }

            function transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public {
                _transferFrom(_from, _to, _tokenId, _amount);
            }

            function _transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount)
                internal
                isOperatorOrOwner(_from)
            {
                require(tokenType[_tokenId] == FT);
                require(_amount <= balanceOf(_from, _tokenId), "Quantity greater than from balance");
                require(_to != address(0), "Invalid to address");

                _updateTokenBalance(_from, _tokenId, _amount, ObjectLib.Operations.SUB);
                _updateTokenBalance(_to, _tokenId, _amount, ObjectLib.Operations.ADD);
                emit TransferWithQuantity(_from, _to, _tokenId, _amount);
            }

            function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public {
                safeTransferFrom(_from, _to, _tokenId, _amount, "");
            }

            function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount, bytes _data) public {
                _transferFrom(_from, _to, _tokenId, _amount);
                require(
                    checkAndCallSafeTransfer(_from, _to, _tokenId, _amount, _data),
                    "Sent to a contract which is not an ERC721X receiver"
                );
            }

            function _mint(uint256 _tokenId, address _to, uint256 _supply) internal {
                // If the token doesn't exist, add it to the tokens array
                if (!exists(_tokenId)) {
                    tokenType[_tokenId] = FT;
                    allTokens.push(_tokenId);
                } else {
                    // if the token exists, it must be a FT
                    require(tokenType[_tokenId] == FT, "Not a FT");
                }

                _updateTokenBalance(_to, _tokenId, _supply, ObjectLib.Operations.ADD);
                emit TransferWithQuantity(address(this), _to, _tokenId, _supply);
            }


            function checkAndCallSafeTransfer(
                address _from,
                address _to,
                uint256 _tokenId,
                uint256 _amount,
                bytes _data
            )
                internal
                returns (bool)
            {
                if (!_to.isContract()) {
                    return true;
                }

                bytes4 retval = ERC721XReceiver(_to).onERC721XReceived(
                    msg.sender, _from, _tokenId, _amount, _data);
                return(retval == ERC721X_RECEIVED);
            }

        }
    answer: >
      pragma solidity ^0.4.25;

      import "./ERC721XToken.sol";

      contract ZombieCard is ERC721XToken {

          mapping(uint => uint) internal tokenIdToIndividualSupply;

          function name() external view returns (string) {
              return "ZombieCard";
          }

          function symbol() external view returns (string) {
              return "ZCX";
          }

          function individualSupply(uint _tokenId) public view returns (uint) {
              return tokenIdToIndividualSupply(_tokenId);
          }

      }
---

å¯¹äºæ™®é€šçš„ ERC20 æˆ– ERC721 ä»£å¸ï¼Œæˆ‘ä»¬æœ‰**_ä»£å¸ä¾›åº”_**çš„æ¦‚å¿µ â€”â€” æ˜¯æŒ‡æ€»å…±å­˜åœ¨å¤šå°‘
é‚£æ ·çš„ä»£å¸ã€‚

å¯¹äº ERC721x å¤šé‡åŒè´¨åŒ–ä»£å¸ï¼Œæˆ‘ä»¬å®é™…ä¸Šå¯ä»¥åœ¨åŒä¸€åˆçº¦ä¸­å®šä¹‰å¤šä¸ªä»£å¸ â€”â€” æ¯ä¸ªä»£å¸
éƒ½æœ‰è‡ªå·±çš„â€œä¾›åº”é‡â€ï¼ˆå­˜åœ¨çš„ä»£å¸æ•°é‡ï¼‰ã€‚

ä½†æ˜¯å½“è°ˆåˆ°æ¸¸æˆç‰©å“æ—¶ï¼Œå¯¹äºæŸäº›ç‰©å“ï¼Œä½ ä¼šæƒ³è¦**æ— é™é‡ä¾›åº”**ã€‚å¦åˆ™ï¼Œå¦‚æœä½ çš„æ¸¸æˆåª
èƒ½æ‹¥æœ‰ 1000 æŠŠå‰‘ï¼Œä½ å°†å—é™åªèƒ½æ‹¥æœ‰ 1000 åç©å®¶ â€”â€” æˆ–è€…å¯¹äºåŠ å…¥è¾ƒæ™šçš„ç©å®¶æ¥è¯´æ¸¸æˆ
ä¸ä¼šå¾ˆå¥½ç©ï¼

åœ¨â€œåƒµå°¸æˆ˜åœºâ€ä¸­ï¼Œæˆ‘ä»¬æœ‰ä¸¤ç§ä¸åŒç±»å‹çš„å¡ç‰Œ â€”â€” å›ºå®šä¾›åº”é‡çš„å¡ç‰Œå’Œæ— é™é‡ä¾›åº”çš„å¡ç‰Œã€‚

- _æ ‡å‡†ç‰ˆå¡ç‰Œ_ï¼šå°±åƒå…¸å‹æ¸¸æˆç‰©å“ä¸€æ ·ï¼Œå®ƒä»¬æ— é™é‡ä¾›åº” â€”â€” è¿™æ ·è¶Šæ¥è¶Šå¤šçš„ç©å®¶å¯ä»¥ç»§
  ç»­åŠ å…¥æ¸¸æˆï¼Œæ¯ä¸ªäººéƒ½æœ‰æœºä¼šè·å¾—å®ƒä»¬å¹¶å»ºç«‹ä¸€ä¸ªæœ‰ç«äº‰åŠ›çš„ç‰Œç»„ã€‚ç”¨é‡‘èæœ¯è¯­æ¥è¯´ï¼Œæˆ‘
  ä»¬ç§°è¿™äº›å¡ç‰Œä¸ºâ€œé€šèƒ€çš„â€ã€‚

- _é™é‡ç‰ˆå¡ç‰Œ_ï¼šå®ƒä»¬æ˜¯æ ‡å‡†ç‰ˆå¡ç‰Œçš„ç¾å·¥å˜ä½“ï¼Œæœ‰å›ºå®šä¾›åº”é‡ã€‚æ˜¯çœ‹èµ·æ¥æ¯”æ ‡å‡†ç‰ˆæ›´é…·çš„
  ç¨€æœ‰æ”¶è—å“ã€‚å› ä¸ºåœ¨æ‰€æœ‰ç”¨æˆ·ä¸­å¯èƒ½åªå­˜åœ¨å‡ ç™¾å¼ ï¼Œè¿™ç§ç¨€ç¼ºæ€§æå‡äº†å®ƒä»¬çš„ä»·å€¼ã€‚

åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†é€æ­¥å‘ä½ ä»‹ç»å¦‚ä½•åœ¨ä½ çš„ä»£å¸åˆçº¦ä¸­å®ç°è¿™ä¸¤ç§ç±»å‹çš„å¡ç‰Œã€‚

## å®ç°è¿‡ç¨‹

å¦‚ä½ æ‰€è§ï¼Œè¿™ä¸¤ç§å¡ç‰Œçš„ä¸»è¦å·®åˆ«å°±æ˜¯`totalSupply` â€”â€” å³å­˜åœ¨çš„å¡ç‰Œæ€»é‡ï¼Œ

é™é‡ç‰ˆå¡ç‰Œå°†ä¼šæœ‰å›ºå®šæ•°é‡çš„`totalSupply`ï¼Œå³`uint`ï¼Œè€Œæ ‡å‡†ç‰ˆå¡ç‰Œæœ‰æ— é™é‡
çš„`totalSupply`ã€‚

ç”±äºæ— é™é‡ä¸æ˜¯ä¸€ä¸ªæˆ‘ä»¬å¯ä»¥è®¾ç½®ä¾›åº”é‡çš„æ•°å­—ï¼Œå¯¹äºæ ‡å‡†ç‰ˆå¡ç‰Œï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶è®¾ç½®
ä¸º`0`ä½œä¸ºå ä½ç¬¦ã€‚ ç„¶ååœ¨æˆ‘ä»¬ä»£ç çš„å…¶ä»–åœ°æ–¹ï¼Œæˆ‘ä»¬å¯ä»¥æ£€æŸ¥ä¾›åº”é‡æ˜¯å¦ç­‰äº`0`ï¼Œå¦‚æœ
æ˜¯ï¼Œæˆ‘ä»¬å°±çŸ¥é“è¿™æ˜¯ä¸€ä¸ªæ— ä¸Šé™ä¾›åº”é‡çš„æ ‡å‡†ç‰ˆå¡ç‰Œã€‚

åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªå‡½æ•°ç”¨æ¥åœ¨æˆ‘ä»¬çš„åˆçº¦ä¸­é“¸é€ æ–°ä»£å¸ã€‚ ä½†é¦–å…ˆï¼Œè®©æˆ‘ä»¬è®¾ç½®
ä¸€äº›å‡½æ•°æ¥è·Ÿè¸ªæ¯å¼ å¡ç‰Œçš„`totalSupply`ã€‚

# å®æˆ˜æ¼”ä¹

1. åˆ›å»ºä¸€ä¸ªåä¸º`tokenIdToIndividualSupply`çš„`æ˜ å°„` ã€‚ å®ƒä¼šå°†ä¸€ä¸ª`uint` æ˜ å°„
   åˆ°`uint`ï¼Œå¹¶ä¸”åº”è¯¥æ˜¯`å†…éƒ¨çš„`ã€‚

2. åˆ›å»ºä¸€ä¸ªåä¸º`individualSupply`çš„`å‡½æ•°`ã€‚ å®ƒåº”è¯¥æ˜¯`å…¬å…±è§†å›¾`ï¼Œ
   å°†`uint _tokenId`ä½œä¸ºå…¶è¾“å…¥ï¼Œå¹¶`è¿”å›`ä¸€ä¸ª`uint`ã€‚

3. å¯¹äºå‡½æ•°ä½“ï¼Œå®ƒåº”è¯¥åª`è¿”å›tokenIdToIndividualSupply(_tokenId)`ã€‚
