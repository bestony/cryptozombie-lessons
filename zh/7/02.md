---
title: â€œåƒµå°¸æˆ˜åœºâ€è‡ªå®šä¹‰æ¸¸æˆæ¨¡å¼çš„åŸºç¡€çŸ¥è¯†
actions: ["checkAnswer", "hints"]
requireLogin: false
material:
  editor:
    language: solidity
    startingCode:
      "examplegame.sol": |
        pragma solidity 0.4.25;

        import "./ZB/ZBGameMode.sol";

        contract ExampleGame is ZBGameMode  {

            // Start here

        }
      "ZBGameMode.sol": |
        // This file is here for your reference, but doesn't contain all the imports necessary
        // to compile. You can find a repo with all the final files at:
        // https://github.com/loomnetwork/zb_game_mode

        pragma solidity ^0.4.25;

        import "./ZBEnum.sol";
        import "./ZBSerializer.sol";

        contract ZBGameMode {
            using ZBSerializer for ZBSerializer.SerializedGameStateChanges;
            using ZBSerializer for GameState;

            enum Player {
                Player1,
                Player2
            }

            struct PlayerState {
                string id;
                //PlayerActionType currentAction = 2;
                //OverlordInstance overlordInstance = 3;
                CardInstance[] cardsInHand;
                //CardInstance[] CardsInPlay;
                CardInstance[] cardsInDeck;
                Deck deck;
                uint8 defense;
                uint8 currentGoo;
                uint8 gooVials;
                uint32 turnTime;
                //bool hasDrawnCard = 11;
                //repeated CardInstance cardsInGraveyard = 12;
                uint8 initialCardsInHandCount;
                uint8 maxCardsInPlay;
                uint8 maxCardsInHand;
                uint8 maxGooVials;
            }

            struct Deck {
                int64 id;
                string name;
                int64 heroId;
            }

            struct CardInstance {
                int32 instanceId;
                string mouldName;
                int32 defense;
                bool defenseInherited;
                int32 attack;
                bool attackInherited;
                int32 gooCost;
                bool gooCostInherited;
            }

            struct GameState {
                int64 id;
                uint8 currentPlayerIndex;
                PlayerState[] playerStates;
            }

            struct Vector2Int {
                int32 x;
                int32 y;
            }

            struct Rect {
                Vector2Int position;
                Vector2Int size;
            }

            struct CustomUiLabel {
                Rect rect;
                string text;
            }

            struct CustomUiButton {
                Rect rect;
                string title;
                bytes onClickCallData;
            }

            event GameStateChanges (
                bytes serializedChanges
            );

            function getInterfaceVersion() external pure returns (int) {
                return 1;
            }

            function getDataStructureVersion() external pure returns (int) {
                return 1;
            }

            function beforeMatchStart(bytes) external {
            }

            function afterInitialDraw(bytes) external {
            }

            function getCustomUi() external view returns (bytes) {
                return new bytes(0);
            }
        }
      "ZBSerializer.sol": |
        // This file is here for your reference, but doesn't contain all the imports necessary
        // to compile. You can find a repo with all the final files at:
        // https://github.com/loomnetwork/zb_game_mode

        pragma solidity ^0.4.25;

        import "./ZBEnum.sol";
        import "./ZBGameMode.sol";
        import "./SerialityBinaryStream.sol";

        library ZBSerializer {
            using SerialityBinaryStream for SerialityBinaryStream.BinaryStream;
            uint constant defaultSerializedGameStateChangesBufferSize = 512;
            uint constant defaultSerializedCustomUiBufferSize = 512;

            event GameStateChanges (
                bytes serializedChanges
            );

            struct SerializedGameStateChanges {
                SerialityBinaryStream.BinaryStream stream;
            }

            struct SerializedCustomUi {
                SerialityBinaryStream.BinaryStream stream;
            }

            // GameState deserialization

            function init(ZBGameMode.GameState memory self, bytes serializedGameState) internal pure {
                SerialityBinaryStream.BinaryStream memory stream =
                    SerialityBinaryStream.BinaryStream(serializedGameState, serializedGameState.length);

                self.id = stream.readInt64();
                self.currentPlayerIndex = stream.readUint8();

                self.playerStates = new ZBGameMode.PlayerState[](2);
                for (uint i = 0; i < self.playerStates.length; i++) {
                    self.playerStates[i] = deserializePlayerState(stream);
                }
            }

            function deserializePlayerState(SerialityBinaryStream.BinaryStream memory stream) private pure returns (ZBGameMode.PlayerState) {
                ZBGameMode.PlayerState memory player;

                player.id = stream.readString();
                player.deck = deserializeDeck(stream);
                player.cardsInHand = deserializeCardInstanceArray(stream);
                player.cardsInDeck = deserializeCardInstanceArray(stream);
                player.defense = stream.readUint8();
                player.currentGoo = stream.readUint8();
                player.gooVials = stream.readUint8();
                player.turnTime = stream.readUint32();
                player.initialCardsInHandCount = stream.readUint8();
                player.maxCardsInPlay = stream.readUint8();
                player.maxCardsInHand = stream.readUint8();
                player.maxGooVials = stream.readUint8();

                return player;
            }

            function serializeCardInstance(SerialityBinaryStream.BinaryStream memory stream, ZBGameMode.CardInstance card) private pure {
                stream.writeInt32(card.instanceId);
                stream.writeString(card.mouldName);
                stream.writeInt32(card.defense);
                stream.writeBool(card.attackInherited);
                stream.writeInt32(card.attack);
                stream.writeBool(card.defenseInherited);
                stream.writeInt32(card.gooCost);
                stream.writeBool(card.gooCostInherited);
            }

            function deserializeCardInstance(SerialityBinaryStream.BinaryStream memory stream) private pure returns (ZBGameMode.CardInstance) {
                ZBGameMode.CardInstance memory card;

                card.instanceId = stream.readInt32();
                card.mouldName = stream.readString();
                card.defense = stream.readInt32();
                card.defenseInherited = stream.readBool();
                card.attack = stream.readInt32();
                card.attackInherited = stream.readBool();
                card.gooCost = stream.readInt32();
                card.gooCostInherited = stream.readBool();

                return card;
            }

            function serializeCardInstanceArray(SerialityBinaryStream.BinaryStream memory stream, ZBGameMode.CardInstance[] cards) internal pure {
                stream.writeUint32(uint32(cards.length));

                for (uint i = 0; i < cards.length; i++) {
                    serializeCardInstance(stream, cards[i]);
                }
            }

            function deserializeCardInstanceArray(SerialityBinaryStream.BinaryStream memory stream) private pure returns (ZBGameMode.CardInstance[]) {
                uint count = stream.readUint32();

                ZBGameMode.CardInstance[] memory cards = new ZBGameMode.CardInstance[](count);
                for (uint i = 0; i < count; i++) {
                    cards[i] = deserializeCardInstance(stream);
                }

                return cards;
            }

            function deserializeDeck(SerialityBinaryStream.BinaryStream memory stream) private pure returns (ZBGameMode.Deck) {
                ZBGameMode.Deck memory deck;
                deck.id = stream.readInt64();
                deck.name = stream.readString();
                deck.heroId = stream.readInt64();

                return deck;
            }

            function serializeStartGameStateChangeAction(
                SerialityBinaryStream.BinaryStream memory stream,
                ZBEnum.GameStateChangeAction action
                ) private pure {
                stream.writeUint32(uint32(action));
            }

            function serializeStartGameStateChangeAction(
                SerialityBinaryStream.BinaryStream memory stream,
                ZBEnum.GameStateChangeAction action,
                ZBGameMode.Player player
                ) private pure {
                stream.writeUint32(uint32(action));
                stream.writeUint8(uint8(player));
            }

            // CardInstance

            function changeMouldName(ZBGameMode.CardInstance memory self, string mouldName) internal pure {
                self.mouldName = mouldName;
            }

            function changeDefense(ZBGameMode.CardInstance memory self, uint8 defense) internal pure {
                self.defense = defense;
                self.defenseInherited = false;
            }

            function changeAttack(ZBGameMode.CardInstance memory self, uint8 attack) internal pure {
                self.attack = attack;
                self.attackInherited = false;
            }

            function changeGooCost(ZBGameMode.CardInstance memory self, uint8 gooCost) internal pure {
                self.gooCost = gooCost;
                self.gooCostInherited = false;
            }

            // SerializedGameStateChanges

            function init(SerializedGameStateChanges memory self) internal pure {
                init(self, defaultSerializedGameStateChangesBufferSize);
            }

            function init(SerializedGameStateChanges memory self, uint bufferSize) internal pure {
                self.stream = SerialityBinaryStream.BinaryStream(new bytes(bufferSize), bufferSize);
            }

            function getBytes(SerializedGameStateChanges memory self) internal pure returns (bytes) {
                return self.stream.buffer;
            }

            function emit(SerializedGameStateChanges memory self) internal {
                emit GameStateChanges(getBytes(self));
            }

            function changePlayerDefense(SerializedGameStateChanges memory self, ZBGameMode.Player player, uint8 defense) internal pure returns (uint) {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerDefense, player);
                stream.writeUint8(uint8(defense));
            }

            function changePlayerCurrentGoo(SerializedGameStateChanges memory self, ZBGameMode.Player player, uint8 currentGoo) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerCurrentGoo, player);
                stream.writeUint8(uint8(currentGoo));
            }

            function changePlayerCurrentGooVials(SerializedGameStateChanges memory self, ZBGameMode.Player player, uint8 gooVials) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerGooVials, player);
                stream.writeUint8(uint8(gooVials));
            }

            function changePlayerCardsInDeck(
                SerializedGameStateChanges memory self,
                ZBGameMode.Player player,
                ZBGameMode.CardInstance[] cards,
                uint cardCount
                ) internal pure {
                require(
                    cardCount <= cards.length,
                    "cardCount > cards.length"
                );

                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerCardsInDeck, player);
                stream.writeUint32(uint32(cardCount));

                for (uint i = 0; i < cardCount; i++) {
                    serializeCardInstance(stream, cards[i]);
                }
            }

            function changePlayerCardsInDeck(
                SerializedGameStateChanges memory self,
                ZBGameMode.Player player,
                ZBGameMode.CardInstance[] cards
                ) internal pure {
                changePlayerCardsInDeck(self, player, cards, cards.length);
            }

            function changePlayerCardsInHand(
                SerializedGameStateChanges memory self,
                ZBGameMode.Player player,
                ZBGameMode.CardInstance[] cards,
                uint cardCount
                ) internal pure {
                require(
                    cardCount <= cards.length,
                    "cardCount > cards.length"
                );

                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerCardsInHand, player);
                stream.writeUint32(uint32(cardCount));

                for (uint i = 0; i < cardCount; i++) {
                    serializeCardInstance(stream, cards[i]);
                }
            }

            function changePlayerCardsInHand(
                SerializedGameStateChanges memory self,
                ZBGameMode.Player player,
                ZBGameMode.CardInstance[] cards
                ) internal pure {
                changePlayerCardsInHand(self, player, cards, cards.length);
            }

            function changePlayerInitialCardsInHandCount(SerializedGameStateChanges memory self, ZBGameMode.Player player, uint8 count) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerInitialCardsInHandCount, player);
                stream.writeUint8(count);
            }

            function changePlayerMaxCardsInPlay(SerializedGameStateChanges memory self, ZBGameMode.Player player, uint8 count) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerMaxCardsInPlay, player);
                stream.writeUint8(count);
            }

            function changePlayerMaxCardsInHand(SerializedGameStateChanges memory self, ZBGameMode.Player player, uint8 count) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerMaxCardsInHand, player);
                stream.writeUint8(count);
            }

            function changePlayerMaxGooVials(SerializedGameStateChanges memory self, ZBGameMode.Player player, uint8 count) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerMaxGooVials, player);
                stream.writeUint8(count);
            }

            function changePlayerTurnTime(SerializedGameStateChanges memory self, ZBGameMode.Player player, uint32 turnTime) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartGameStateChangeAction(stream, ZBEnum.GameStateChangeAction.SetPlayerTurnTime, player);
                stream.writeUint32(turnTime);
            }

            // SerializedCustomUi

            function init(SerializedCustomUi memory self) internal pure {
                init(self, defaultSerializedCustomUiBufferSize);
            }

            function init(SerializedCustomUi memory self, uint bufferSize) internal pure {
                self.stream = SerialityBinaryStream.BinaryStream(new bytes(bufferSize), bufferSize);
            }

            function getBytes(SerializedCustomUi memory self) internal pure returns (bytes) {
                return self.stream.buffer;
            }

            function add(SerializedCustomUi memory self, ZBGameMode.CustomUiLabel label) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartCustomUiElement(stream, ZBEnum.CustomUiElement.Label, label.rect);
                stream.writeString(label.text);
            }

            function add(SerializedCustomUi memory self, ZBGameMode.CustomUiButton button) internal pure {
                SerialityBinaryStream.BinaryStream memory stream = self.stream;

                serializeStartCustomUiElement(stream, ZBEnum.CustomUiElement.Button, button.rect);
                stream.writeString(button.title);
                stream.writeBytes(button.onClickCallData);
            }

            function serializeStartCustomUiElement(SerialityBinaryStream.BinaryStream memory stream, ZBEnum.CustomUiElement element) private pure {
                stream.writeInt32(int32(element));
            }

            function serializeStartCustomUiElement(
                SerialityBinaryStream.BinaryStream memory stream,
                ZBEnum.CustomUiElement element,
                ZBGameMode.Rect rect
                ) private pure {
                serializeStartCustomUiElement(stream, element);
                serializeRect(stream, rect);
            }

            function serializeRect(SerialityBinaryStream.BinaryStream memory stream, ZBGameMode.Rect rect) private pure {
                serializeVector2Int(stream, rect.position);
                serializeVector2Int(stream, rect.size);
            }

            function serializeVector2Int(SerialityBinaryStream.BinaryStream memory stream, ZBGameMode.Vector2Int v) private pure {
                stream.writeInt32(v.x);
                stream.writeInt32(v.y);
            }
        }
    answer: |
      pragma solidity 0.4.25;

      import "./ZB/ZBGameMode.sol";

      contract ExampleGame is ZBGameMode  {

          function beforeMatchStart(bytes serializedGameState) external {

          }
      }
---

â€œåƒµå°¸æˆ˜åœºâ€è‡ªå®šä¹‰æ¸¸æˆæ¨¡å¼åˆçº¦çš„å¤–å£³å°±åƒ Solidity ä¸­çš„ä»»ä½•å…¶ä»–æ™ºèƒ½åˆçº¦ä¸€æ ·å¼€å§‹ï¼Œå¦‚
å³ä¾§æ‰€ç¤ºã€‚

é¦–å…ˆè¦æ³¨æ„çš„æ˜¯ï¼Œæˆ‘ä»¬ä»ä¸€ä¸ªåä¸º`ZBGameMode.sol`çš„æ–‡ä»¶å¯¼å…¥ï¼Œè¯¥æ–‡ä»¶
ä»`ZBSerializer.sol`å’Œå…¶ä»–ä¸€äº›æ–‡ä»¶å¯¼å…¥ã€‚

> æ³¨æ„ï¼šå…¶ä¸­ä¸€äº›æ–‡ä»¶éå¸¸å¤§ï¼Œå› æ­¤æˆ‘ä»¬æ²¡æœ‰å°†å®ƒä»¬åŒ…å«åœ¨æœ¬è¯¾ç¨‹ä¸­ã€‚ ä½ å¯ä»¥è®¿é—®
> <a href="https://github.com/loomnetwork/zb_game_mode" target=_blank>æ­¤ github
> ä»£ç åº“</a> çš„å®Œæ•´æºä»£ç ã€‚ ä½ ä¸å¿…æ‹…å¿ƒé˜…è¯»/ç†è§£ä¸äº†è¿™äº›æ–‡ä»¶çš„å†…å®¹ â€”â€” æˆ‘ä»¬å°†è§£é‡Š
> ä½ éœ€è¦çŸ¥é“çš„ç›¸å…³éƒ¨åˆ†ï¼Œä»¥ä¾¿åˆ›å»ºè‡ªå®šä¹‰æ¸¸æˆæ¨¡å¼ã€‚

Since our contract, `ExampleGame`, inherits from `ZBGameMode`, this gives us
access to a bunch of common data structures and helper methods we've created to
make your life easier as a custom game mode developer. ç”±äºæˆ‘ä»¬çš„åˆ
çº¦`ExampleGame`ç»§æ‰¿è‡ª`ZBGameMode`ï¼Œå› æ­¤ä½ å¯ä»¥è®¿é—®æˆ‘ä»¬åˆ›å»ºçš„ä¸€ç³»åˆ—å¸¸è§æ•°æ®ç»“æ„å’Œ
è¾…åŠ©æ–¹æ³•ï¼Œä»è€Œè®©ä½ è½»æ¾æˆä¸ºè‡ªå®šä¹‰æ¸¸æˆæ¨¡å¼å¼€å‘äººå‘˜ã€‚

æˆ‘ä»¬å·²ç»å°†å®ƒä»¬æŠ½è±¡åˆ°ä¸€ä¸ªåº“ä¸­ï¼Œå› æ­¤ä½ ä¸éœ€è¦åœ¨æ¯ä¸ªè‡ªå®šä¹‰æ¸¸æˆæ¨¡å¼ä¸­éƒ½ä½¿ç”¨ç›¸åŒçš„æ ·æ¿
é€»è¾‘ã€‚

### "hookï¼ˆé’©å­ï¼‰" â€” æ¯ä¸ªè‡ªå®šä¹‰æ¸¸æˆæ¨¡å¼çš„æ ¸å¿ƒ

æ¯ä¸ªè‡ªå®šä¹‰æ¸¸æˆæ¨¡å¼çš„ç¬¬ä¸€æ­¥å°±æ˜¯å®ç°è‡³å°‘ä¸€ä¸ª**_hook_**ã€‚

åŸºæœ¬ä¸Šï¼Œæ ¸å¿ƒæ¸¸æˆé€»è¾‘å°†åœ¨æ¸¸æˆçš„æŸäº›éƒ¨åˆ†ä¸­ï¼ˆå¦‚æœå®ƒä»¬å­˜åœ¨äºä½ çš„ä»£ç ä¸­ï¼‰å¯»æ‰¾å¹¶è°ƒç”¨åˆ
çº¦ä¸­çš„æŸäº›åŠŸèƒ½ã€‚

ä¾‹å¦‚ï¼Œ`beforeMatchStart`å°†åœ¨æ¯”èµ›å¼€å§‹ä¹‹å‰è°ƒç”¨; `afterInitialDraw`ä¼šåœ¨ç©å®¶æŠ½å‡ºç¬¬ä¸€
å¼ ç‰Œåç«‹å³è°ƒç”¨; `beforeTurnStart` _ï¼ˆå·²è®¡åˆ’ä½†å°šæœªå®ç°ï¼‰_ å°†åœ¨æ¯ä¸ªç©å®¶å›åˆå¼€å§‹æ—¶
è§¦å‘ã€‚

è¿™äº› hook å…è®¸ä½ â€œç‚¹å‡»â€å¹¶ä¿®æ”¹é‚£æ—¶çš„æ¸¸æˆçŠ¶æ€ï¼Œåœ¨æ¸¸æˆç»§ç»­ä¹‹å‰åº”ç”¨ä½ çš„è‡ªå®šä¹‰è§„åˆ™ã€‚

æˆ‘ä»¬å°†å®ç°çš„ç¬¬ä¸€ä¸ª hook å«åš`beforeMatchStart`ï¼Œé¡¾åæ€ä¹‰, å®ƒæ˜¯åº”ç”¨åœ¨æ¯åœºæ¯”èµ›å¼€å§‹
ä¹‹å‰çš„ hookã€‚

å‡½æ•°å®šä¹‰å¦‚ä¸‹æ‰€ç¤ºï¼š

```
function beforeMatchStart(bytes serializedGameState) external {
    // Define changes to the game state here
}
```

åœ¨å‡½æ•°å†…éƒ¨ï¼Œä½ å°†å®šä¹‰æ¯”èµ›å¼€å§‹æ—¶è¦åº”ç”¨çš„å¯¹æ¸¸æˆé€»è¾‘çš„æ‰€æœ‰è‡ªå®šä¹‰æ›´æ”¹ã€‚

è¿™äº›æ›´æ”¹å¯èƒ½æ˜¯å¯¹å•ä¸ªå¡ç‰Œçš„å¹³è¡¡å˜åŒ–ã€åœ¨æ­¤æ¸¸æˆæ¨¡å¼ä¸­å…è®¸/ç¦æ­¢å¡ç‰Œçš„è§„åˆ™ã€ä»¥åŠå¯¹
overlord ç”Ÿå‘½å€¼çš„æ›´æ”¹æˆ–è€… goo å°ç“¶çš„èµ·å§‹æ•°é‡ç­‰ã€‚

> ä»æœªç©è¿‡â€œåƒµå°¸æˆ˜åœºâ€å¹¶ä¸”ä¸ç¡®å®šè¿™äº›æœ¯è¯­æŒ‡çš„æ˜¯ä»€ä¹ˆï¼Ÿ è¯·é˜…
> è¯»<a href="https://zombiebattleground.io/index.php/Gameplay" target=_blank>â€œåƒµ
> å°¸æˆ˜åœºâ€æ¸¸æˆè§„åˆ™ç®€ä»‹</a>ã€‚

## `å­—èŠ‚ serializedGameState`

`beforeMatchStart` æ¥å—ä¸€ä¸ªå‚æ•° â€”â€” å«åš`serializedGameState`çš„`å­—èŠ‚`ã€‚

è¿™æ˜¯ä¸€ä¸ªæœ‰ç‚¹è®¨åŒçš„å­—èŠ‚ç å—ï¼Œå…¶ä¸­åŒ…å«**æ¸¸æˆçš„æ•´ä¸ªå½“å‰çŠ¶æ€** â€”â€” ç‰Œç»„ä¸­æ‰€æœ‰çš„ç©å®¶å¡
ç‰Œã€ä»–ä»¬çš„ overlord ç”Ÿå‘½å€¼ã€ä»–ä»¬æ‹¥æœ‰çš„ goo å°ç“¶æ•°é‡ç­‰ç­‰ â€”â€” éƒ½æµ“ç¼©æˆä¸€ä¸ªé•¿é•¿çš„å­—
ç¬¦ä¸²ã€‚

å®ƒçœ‹èµ·æ¥å°±åƒè¿™æ ·ï¼š

```
// Oooooommmmmgggg......
00000000000000024765797a6572000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060000000000000004467265657a7a6565000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000044a65747465720000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000600000000000000044f7a6d6f7a697a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000700000000000000045a6e6f776d616e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000070000000000000004497a7a65000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000443657262657275730000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000447617267616e7475610000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000908000000000000000244656661756c743200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000002011400000000000000025a68616d70696f6e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000004466972652d4d6177000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000044d6f646f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000004576572657a6f6d620000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000443796e6465726d616e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009000000000000000442757272726e6e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000700000000000000045175617a69000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000000000000045079726f6d617a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000708000000000000000144656661756c7431000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000010114000000000000000005
```

After we receive this nasty-looking byte array, weâ€™ll convert it into a format
thatâ€™s easy to work with â€” which weâ€™ll look at in the next chapters. åœ¨æˆ‘ä»¬æ”¶åˆ°
è¿™ä¸ªæœ‰ç‚¹è®¨åŒçš„å­—èŠ‚æ•°ç»„åï¼Œæˆ‘ä»¬ä¼šå°†å…¶è½¬æ¢ä¸ºæ˜“äºä½¿ç”¨çš„æ ¼å¼ â€”â€” å°†åœ¨åé¢çš„ç« èŠ‚ä¸­ä»‹ç»
ã€‚

ä¹‹æ‰€ä»¥ä¸ä»¥äººç±»å¯è¯»æ ¼å¼ä¼ é€’æ•°æ®è€Œä»¥è¿™ç§æ–¹å¼ï¼Œæ˜¯å› ä¸ºè¿™æ˜¯åœ¨â€œåƒµå°¸æˆ˜åœºâ€æ ¸å¿ƒæ¸¸æˆä»£ç å’Œ
è‡ªå®šä¹‰æ¸¸æˆçŠ¶æ€æ™ºèƒ½åˆçº¦ä¹‹é—´æ¥å›ä¼ é€’å¤§é‡æ•°æ®çš„æ›´æœ‰æ•ˆæ–¹æ³•ã€‚

## å®æˆ˜æ¼”ä¹

1. å®šä¹‰ä¸€ä¸ªåä¸º`beforeMatchStart`çš„`å‡½æ•°`ã€‚ å®ƒå°†é‡‡ç”¨ä¸€ä¸ªå‚æ•°ï¼Œä¸€ä¸ªå
   ä¸º`serializedGameState`çš„`å­—èŠ‚`ã€‚ è¿™ä¸ªå‡½æ•°åº”è¯¥æ˜¯`external`ã€‚

2. æš‚æ—¶å°†å‡½æ•°ä½“ç•™ç©º â€”â€” æˆ‘ä»¬å°†åœ¨ä¸‹ä¸€ç« æ¥å¡«å†™å®ƒã€‚
