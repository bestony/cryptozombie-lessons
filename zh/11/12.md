---
title: åƒµå°¸æˆ˜æ–—
actions: ["checkAnswer", "hints"]
requireLogin: true
material:
  editor:
    language: javascript
    startingCode:
      "test/CryptoZombies.js": |
        const CryptoZombies = artifacts.require("CryptoZombies");
        const utils = require("./helpers/utils");
        const time = require("./helpers/time");
        const zombieNames = ["Zombie 1", "Zombie 2"];
        contract("CryptoZombies", (accounts) => {
            let [alice, bob] = accounts;
            let contractInstance;
            beforeEach(async () => {
                contractInstance = await CryptoZombies.new();
            });
            it("should be able to create a new zombie", async () => {
                const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                assert.equal(result.receipt.status, true);
                assert.equal(result.logs[0].args.name,zombieNames[0]);
            })
            it("should not allow two zombies", async () => {
                await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                await utils.shouldThrow(contractInstance.createRandomZombie(zombieNames[1], {from: alice}));
            })
            context("with the single-step transfer scenario", async () => {
                it("should transfer a zombie", async () => {
                    const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                    const zombieId = result.logs[0].args.zombieId.toNumber();
                    await contractInstance.transferFrom(alice, bob, zombieId, {from: alice});
                    const newOwner = await contractInstance.ownerOf(zombieId);
                    assert.equal(newOwner, bob);
                })
            })
            context("with the two-step transfer scenario", async () => {
                it("should approve and then transfer a zombie when the approved address calls transferForm", async () => {
                    const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                    const zombieId = result.logs[0].args.zombieId.toNumber();
                    await contractInstance.approve(bob, zombieId, {from: alice});
                    await contractInstance.transferFrom(alice, bob, zombieId, {from: bob});
                    const newOwner = await contractInstance.ownerOf(zombieId);
                    assert.equal(newOwner,bob);
                })
                it("should approve and then transfer a zombie when the owner calls transferForm", async () => {
                    const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                    const zombieId = result.logs[0].args.zombieId.toNumber();
                    await contractInstance.approve(bob, zombieId, {from: alice});
                    await contractInstance.transferFrom(alice, bob, zombieId, {from: alice});
                    const newOwner = await contractInstance.ownerOf(zombieId);
                    assert.equal(newOwner,bob);
                 })
            })
            it("zombies should be able to attack another zombie", async () => {
                let result;
                result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                const firstZombieId = result.logs[0].args.zombieId.toNumber();
                result = await contractInstance.createRandomZombie(zombieNames[1], {from: bob});
                const secondZombieId = result.logs[0].args.zombieId.toNumber();
                //TODO: increase the time
                await contractInstance.attack(firstZombieId, secondZombieId, {from: alice});
                assert.equal(result.receipt.status, true);
            })
        })
      "test/helpers/utils.js": |
        async function shouldThrow(promise) {
        try {
            await promise;
            assert(true);
        }
        catch (err) {
            return;
        }
        assert(false, "The contract did not throw.");

        }

        module.exports = {
            shouldThrow,
        };

      "test/helpers/time.js": |
        async function increase(duration) {

            //first, let's increase time
            await web3.currentProvider.sendAsync({
                jsonrpc: "2.0",
                method: "evm_increaseTime",
                params: [duration], // 86400 seconds in a day
                id: new Date().getTime()
            }, () => {});

            //next, let's mine a new block
            web3.currentProvider.send({
                jsonrpc: '2.0',
                method: 'evm_mine',
                params: [],
                id: new Date().getTime()
            })

        }

        const duration = {

            seconds: function (val) {
                return val;
            },
            minutes: function (val) {
                return val * this.seconds(60);
            },
            hours: function (val) {
                return val * this.minutes(60);
            },
            days: function (val) {
                return val * this.hours(24);
            },
        }

        module.exports = {
            increase,
            duration,
        };

    answer: >
      const CryptoZombies = artifacts.require("CryptoZombies");

      const utils = require("./helpers/utils");

      const time = require("./helpers/time");

      const zombieNames = ["Zombie 1", "Zombie 2"];

      contract("CryptoZombies", (accounts) => {
          let [alice, bob] = accounts;
          let contractInstance;
          beforeEach(async () => {
              contractInstance = await CryptoZombies.new();
          });
          it("should be able to create a new zombie", async () => {
              const result = await
      contractInstance.createRandomZombie(zombieNames[0], {from: alice});
              assert.equal(result.receipt.status, true);
              assert.equal(result.logs[0].args.name,zombieNames[0]);
          })
          it("should not allow two zombies", async () => {
              await contractInstance.createRandomZombie(zombieNames[0], {from:
      alice});
              await
      utils.shouldThrow(contractInstance.createRandomZombie(zombieNames[1],
      {from: alice}));
          })
          context("with the single-step transfer scenario", async () => {
              it("should transfer a zombie", async () => {
                  const result = await
      contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                  const zombieId = result.logs[0].args.zombieId.toNumber();
                  await contractInstance.transferFrom(alice, bob, zombieId,
      {from: alice});
                  const newOwner = await contractInstance.ownerOf(zombieId);
                  assert.equal(newOwner, bob);
              })
          })
          context("with the two-step transfer scenario", async () => {
              it("should approve and then transfer a zombie when the approved
      address calls transferForm", async () => {
                  const result = await
      contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                  const zombieId = result.logs[0].args.zombieId.toNumber();
                  await contractInstance.approve(bob, zombieId, {from: alice});
                  await contractInstance.transferFrom(alice, bob, zombieId,
      {from: bob});
                  const newOwner = await contractInstance.ownerOf(zombieId);
                  assert.equal(newOwner,bob);
              })
              it("should approve and then transfer a zombie when the owner calls
      transferForm", async () => {
                  const result = await
      contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                  const zombieId = result.logs[0].args.zombieId.toNumber();
                  await contractInstance.approve(bob, zombieId, {from: alice});
                  await contractInstance.transferFrom(alice, bob, zombieId,
      {from: alice});
                  const newOwner = await contractInstance.ownerOf(zombieId);
                  assert.equal(newOwner,bob);
               })
          })
          it("zombies should be able to attack another zombie", async () => {
              let result;
              result = await contractInstance.createRandomZombie(zombieNames[0],
      {from: alice});
              const firstZombieId = result.logs[0].args.zombieId.toNumber();
              result = await contractInstance.createRandomZombie(zombieNames[1],
      {from: bob});
              const secondZombieId = result.logs[0].args.zombieId.toNumber();
              await time.increase(time.duration.days(1));
              await contractInstance.attack(firstZombieId, secondZombieId,
      {from: alice});
              assert.equal(result.receipt.status, true);
          })
      })
---

å“‡å“¦ï¼å‰å‡ ç« çš„ä¿¡æ¯é‡æœ‰ç‚¹å¤§å“¦ï¼Œä½†å¾ˆå¤šéƒ½æ˜¯åŸºç¡€å†…å®¹ã€‚

æ‰€ä»¥ï¼Œå…¨éƒ¨çš„åœºæ™¯éƒ½è®²å®Œäº†å—ï¼Ÿè¿˜æ²¡æœ‰å“¦ï¼Œå‹è½´çš„éƒ¨åˆ†è‚¯å®šä¼šæ”¾åœ¨æœ€åå•¦ã€‚

æˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªåƒµå°¸æ¸¸æˆï¼Œé‚£ä¹ˆ**æœ€ç²¾å½©çš„éƒ¨åˆ†**æ˜¯åƒµå°¸ä¹‹é—´çš„æˆ˜æ–—ï¼Œå¯¹å§?

è¿™ä¸ªæµ‹è¯•éå¸¸ç®€å•ï¼ŒåŒ…æ‹¬ä»¥ä¸‹æ­¥éª¤:

- **ç¬¬ä¸€æ­¥**ï¼Œæˆ‘ä»¬å°†åˆ›å»ºä¸¤ä¸ªæ–°åƒµå°¸ â€”â€” ä¸€ä¸ª Alice çš„ï¼Œä¸€ä¸ª Bob çš„ã€‚
- **ç¬¬äºŒæ­¥**ï¼ŒAlice å°†ä»¥ Bob çš„ `zombieId` ä½œä¸ºå‚æ•°åœ¨å¥¹çš„åƒµå°¸ä¸Šè¿è¡Œ `attack`ã€‚
- **æœ€å**ï¼Œä¸ºäº†ä½¿æµ‹è¯•é€šè¿‡ï¼Œæˆ‘ä»¬å°†æ£€æŸ¥ `result.receipt.status` æ˜¯å¦ç­‰äº `true`ã€‚

å‡è®¾æˆ‘å·²ç»å¿«é€Ÿç¼–å†™äº†æ‰€æœ‰è¿™äº›é€»è¾‘ï¼Œå°†å…¶å°è£…åœ¨ä¸€ä¸ª `it()` å‡½æ•°ä¸­ï¼Œå¹¶è¿è¡Œäº†
`truffle test` æµ‹è¯•ã€‚

ç„¶åï¼Œè¾“å‡ºä¼šåƒè¿™æ ·:

```bash
Contract: CryptoZombies
    âœ“ should be able to create a new zombie (102ms)
    âœ“ should not allow two zombies (321ms)
    âœ“ should return the correct owner (333ms)
    1) zombies should be able to attack another zombie
    with the single-step transfer scenario
      âœ“ should transfer a zombie (307ms)
    with the two-step transfer scenario
      âœ“ should approve and then transfer a zombie when the approved address calls transferFrom (357ms)


  5 passing (7s)
  1 failing

  1) Contract: CryptoZombies
       zombies should be able to attack another zombie:
     Error: Returned error: VM Exception while processing transaction: revert

```

å“¦ï¼Œæµ‹è¯•å¤±è´¥äº† â˜¹ï¸ã€‚

ä¸ºä»€ä¹ˆå‘¢ï¼Ÿ

è¦ææ¸…æ¥šæ˜¯æ€ä¹ˆå›äº‹ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬æ¥ä»”ç»†çœ‹çœ‹ `createRandomZombie()` èƒŒåçš„ä»£ç :

```sol
function createRandomZombie(string _name) public {
  require(ownerZombieCount[msg.sender] == 0);
  uint randDna = _generateRandomDna(_name);
  randDna = randDna - randDna % 100;
  _createZombie(_name, randDna);
}
```

ç›®å‰ä¸ºæ­¢éƒ½æ²¡é—®é¢˜ã€‚ç»§ç»­ï¼Œçœ‹ä¸‹ `_createZombie()`ï¼š

```sol
function _createZombie(string _name, uint _dna) internal {
  uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1;
  zombieToOwner[id] = msg.sender;
  ownerZombieCount[msg.sender] = ownerZombieCount[msg.sender].add(1);
  emit NewZombie(id, _name, _dna);
}
```

çœ‹åˆ°é—®é¢˜äº†å—ï¼Ÿ

æµ‹è¯•å¤±è´¥çš„åŸå› æ˜¯å› ä¸ºæˆ‘ä»¬åœ¨æ¸¸æˆä¸­å¢åŠ äº†ä¸€ä¸ª**å†·å´æ—¶é—´**ï¼Œä½¿å¾—åƒµå°¸åœ¨æ”»å‡»ï¼ˆæˆ–è¿›é£Ÿï¼‰
åå¿…é¡»ç­‰å¾…**1 å¤©**æ‰èƒ½å†æ¬¡æ”»å‡»ã€‚

æ²¡æœ‰è¿™ä¸ªçš„è¯ï¼Œåƒµå°¸æ¯å¤©å¯ä»¥æ— æ•°æ¬¡æ”»å‡»å’Œå¢æ®–ï¼Œè¿™å°†è®©æ¸¸æˆå¾ˆå¼±æ™ºã€‚ã€‚

ç°åœ¨æˆ‘ä»¬è¯¥æ€ä¹ˆåŠå‘¢â€¦â€¦ ç­‰ä¸€å¤©å—ï¼Ÿ

## æ—¶é—´æ—…è¡Œ

å¹¸å¥½ï¼Œæˆ‘ä»¬ä¸å¿…ç­‰é‚£ä¹ˆä¹…ã€‚äº‹å®ä¸Šï¼Œæ ¹æœ¬å°±ä¸éœ€è¦ç­‰ã€‚å› ä¸º _Ganache_ æä¾›äº†ä¸€ç§é€šè¿‡ä¸¤
ä¸ªè¾…åŠ©åŠŸèƒ½åŠæ—¶å‰è¡Œçš„æ–¹æ³•ï¼š

- `evm_increaseTime`: å¢åŠ ä¸‹ä¸€ä¸ªåŒºå—çš„æ—¶é—´ã€‚
- `evm_mine`: æŒ–ä¸€ä¸ªæ–°åŒºå—.

ä½ ç”šè‡³ä¸éœ€è¦ Tardis æˆ– DeLorean æ¥è¿›è¡Œè¿™ç§æ—¶é—´æ—…è¡Œã€‚

è®©æˆ‘æ¥è§£é‡Šä¸‹è¿™äº›å‡½æ•°æ˜¯å¦‚ä½•è¿è¡Œçš„:

- æ¯æ¬¡æŒ–ä¸€ä¸ªæ–°åŒºå—æ—¶ï¼ŒçŸ¿å·¥éƒ½ä¼šå‘å®ƒæ·»åŠ ä¸€ä¸ªæ—¶é—´æˆ³ã€‚å‡è®¾åœ¨ç¬¬ 5 ä¸ªåŒºå—ä¸­æŒ–åˆ°äº†ç”Ÿæˆ
  åƒµå°¸çš„äº‹åŠ¡ã€‚

- æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬è°ƒç”¨ `evm_increaseTime`ï¼Œä½†ç”±äºåŒºå—é“¾æ˜¯ä¸å¯å˜çš„ï¼Œæ‰€ä»¥ä¸å¯èƒ½ä¿®æ”¹ç°
  æœ‰åŒºå—ã€‚æ‰€ä»¥ï¼Œå½“åˆçº¦æ£€æŸ¥æ—¶é—´æ—¶ï¼Œå®ƒä¸ä¼šå¢åŠ ã€‚

- å¦‚æœæˆ‘ä»¬è¿è¡Œ `evm_mine`ï¼Œé‚£ä¹ˆç¬¬ 6 ä¸ªåŒºå—å°±ä¼šè¢«æŒ–å‡ºï¼ˆå¹¶åŠ ä¸Šæ—¶é—´æˆ³ï¼‰ï¼Œè¿™æ„å‘³ç€ï¼Œ
  å½“æˆ‘ä»¬è®©åƒµå°¸æŠ•å…¥æˆ˜æ–—æ—¶ï¼Œæ™ºèƒ½åˆçº¦å°†â€œçœ‹åˆ°â€ä¸€å¤©å·²ç»è¿‡å»äº†ã€‚

ç»¼ä¸Šæ‰€è¿°ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æ—¶é—´æ—…è¡Œæ¥ä¿®æ­£æˆ‘ä»¬çš„æµ‹è¯•ï¼Œå…·ä½“ä»¥ä¸‹:

```javascript
await web3.currentProvider.sendAsync(
  {
    jsonrpc: "2.0",
    method: "evm_increaseTime",
    params: [86400], // there are 86400 seconds in a day
    id: new Date().getTime()
  },
  () => {}
);

web3.currentProvider.send({
  jsonrpc: "2.0",
  method: "evm_mine",
  params: [],
  id: new Date().getTime()
});
```

å—¯ï¼Œè¿™æ®µä»£ç ä¸é”™ï¼Œä½†æ˜¯æˆ‘ä»¬ä¸ä¼šå°†è¿™ä¸ªé€»è¾‘æ·»åŠ åˆ°æˆ‘ä»¬çš„ `CryptoZombies.js` æ–‡ä»¶ä¸­ã€‚

æˆ‘ä»¬å·²ç»å°†æ‰€æœ‰å†…å®¹ç§»åŠ¨åˆ°ä¸€ä¸ªåä¸º `helpers/time.js` çš„æ–°æ–‡ä»¶ä¸­äº†ã€‚è¦å¢åŠ æ—¶é—´ï¼Œåª
éœ€è°ƒç”¨ï¼š`time.increaseTime(86400);`

å—¯ï¼Œè¿˜ä¸å¤Ÿå®Œç¾ã€‚æ¯•ç«Ÿï¼Œé¬¼æ‰çŸ¥é“ä¸€å¤©æœ‰å¤šå°‘ç§’å‘¢ã€‚

æ‰€ä»¥æˆ‘ä»¬æ·»åŠ äº†å¦ä¸€ä¸ªåä¸º `days` çš„ _è¾…åŠ©å‡½æ•°_ï¼Œå®ƒä»¥å¸Œæœ›å¢åŠ æ—¶é—´çš„å¤©æ•°ä½œä¸ºå‚æ•°ã€‚
ä½ å¯ä»¥è¿™æ ·æ¥è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼š`await time.increase(time.duration.days(1))`

> æ³¨æ„ï¼šå¾ˆæ˜æ˜¾ï¼Œæ—¶é—´æ—…è¡Œåœ¨ä¸»ç½‘æˆ–ä»»ä½•ç”±çŸ¿å·¥ä¿æŠ¤çš„ç°æœ‰æµ‹è¯•é“¾ä¸Šéƒ½æ˜¯ä¸å¯ç”¨çš„ã€‚å¦‚æœæœ‰
> äººå¯ä»¥æ”¹å˜ç°å®ä¸–ç•Œä¸­æ—¶é—´çš„è¿ä½œæ–¹å¼ï¼Œé‚£å²‚ä¸å°±ä¹±å¥—äº†ï¼å¯¹äºæµ‹è¯•æ™ºèƒ½åˆçº¦ï¼Œæ—¶é—´æ—…è¡Œ
> å¯æ˜¯ç¨‹åºå‘˜ç›¸å½“é‡è¦çš„ä¸€é¡¹æŠ€èƒ½ã€‚

# å®æˆ˜æ¼”ä¹

æˆ‘ä»¬ç»§ç»­å¡«å……äº†é‚£ç‰ˆå¤±è´¥çš„æµ‹è¯•ã€‚

1.  å¾€ä¸‹æ»šåŠ¨ï¼Œçœ‹ä¸‹æˆ‘ä»¬ç»™ä½ çš„ç•™è¨€ã€‚æ¥ä¸‹æ¥ï¼Œå¦‚ä¸Šæ‰€ç¤ºï¼Œé€šè¿‡è¿è¡Œ
    `await time.increase` æ¥ä¿®å¤æµ‹è¯•ç”¨ä¾‹ã€‚ã€‚

å‡†å¤‡å°±ç»ªã€‚å¼€å§‹è¿è¡Œ `truffle test`ï¼š

```
Contract: CryptoZombies
    âœ“ should be able to create a new zombie (119ms)
    âœ“ should not allow two zombies (112ms)
    âœ“ should return the correct owner (109ms)
    âœ“ zombies should be able to attack another zombie (475ms)
    with the single-step transfer scenario
      âœ“ should transfer a zombie (235ms)
    with the two-step transfer scenario
      âœ“ should approve and then transfer a zombie when the owner calls transferForm (181ms)
      âœ“ should approve and then transfer a zombie when the approved address calls transferForm (152ms)
```

å¥½äº†ï¼è¿™å°±æ˜¯æœ¬ç« æœ€åä¸€æ­¥ã€‚
