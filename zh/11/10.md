---
title: ERC721 ä»£å¸è½¬ç§» â€”â€” ä¸¤æ­¥åœºæ™¯
actions: ["checkAnswer", "hints"]
requireLogin: true
material:
  editor:
    language: javascript
    startingCode:
      "test/CryptoZombies.js": |
        const CryptoZombies = artifacts.require("CryptoZombies");
        const utils = require("./helpers/utils");
        const zombieNames = ["Zombie 1", "Zombie 2"];
        contract("CryptoZombies", (accounts) => {
            let [alice, bob] = accounts;
            let contractInstance;
            beforeEach(async () => {
                contractInstance = await CryptoZombies.new();
            });
            it("should be able to create a new zombie", async () => {
                const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                assert.equal(result.receipt.status, true);
                assert.equal(result.logs[0].args.name,zombieNames[0]);
            })
            it("should not allow two zombies", async () => {
                await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                await utils.shouldThrow(contractInstance.createRandomZombie(zombieNames[1], {from: alice}));
            })
            context("with the single-step transfer scenario", async () => {
                it("should transfer a zombie", async () => {
                    const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                    const zombieId = result.logs[0].args.zombieId.toNumber();
                    await contractInstance.transferFrom(alice, bob, zombieId, {from: alice});
                    const newOwner = await contractInstance.ownerOf(zombieId);
                    assert.equal(newOwner, bob);
                })
            })
            xcontext("with the two-step transfer scenario", async () => {
                it("should approve and then transfer a zombie when the approved address calls transferForm", async () => {
                    const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                    const zombieId = result.logs[0].args.zombieId.toNumber();
                    // start here
                    await contractInstance.transferFrom(alice, bob, zombieId, {from: alice});
                    const newOwner = await contractInstance.ownerOf(zombieId);
                    assert.equal(newOwner,bob);
                })
                it("should approve and then transfer a zombie when the owner calls transferForm", async () => {
                    // TODO: Test the two-step scenario.  The owner calls transferFrom
                 })
            })
        })
      "test/helpers/utils.js": |
        async function shouldThrow(promise) {
        try {
            await promise;
            assert(true);
        }
        catch (err) {
            return;
        }
        assert(false, "The contract did not throw.");

        }

        module.exports = {
            shouldThrow,
        };

    answer: >
      const CryptoZombies = artifacts.require("CryptoZombies");

      const utils = require("./helpers/utils");

      const zombieNames = ["Zombie 1", "Zombie 2"];

      contract("CryptoZombies", (accounts) => {
          let [alice, bob] = accounts;
          let contractInstance;
          beforeEach(async () => {
              contractInstance = await CryptoZombies.new();
          });
          it("should be able to create a new zombie", async () => {
              const result = await
      contractInstance.createRandomZombie(zombieNames[0], {from: alice});
              assert.equal(result.receipt.status, true);
              assert.equal(result.logs[0].args.name,zombieNames[0]);
          })
          it("should not allow two zombies", async () => {
              await contractInstance.createRandomZombie(zombieNames[0], {from:
      alice});
              await
      utils.shouldThrow(contractInstance.createRandomZombie(zombieNames[1],
      {from: alice}));
          })
          context("with the single-step transfer scenario", async () => {
              it("should transfer a zombie", async () => {
                  const result = await
      contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                  const zombieId = result.logs[0].args.zombieId.toNumber();
                  await contractInstance.transferFrom(alice, bob, zombieId,
      {from: alice});
                  const newOwner = await contractInstance.ownerOf(zombieId);
                  assert.equal(newOwner, bob);
              })
          })
          context("with the two-step transfer scenario", async () => {
              it("should approve and then transfer a zombie when the approved
      address calls transferForm", async () => {
                  const result = await
      contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                  const zombieId = result.logs[0].args.zombieId.toNumber();
                  await contractInstance.approve(bob, zombieId, {from: alice});
                  await contractInstance.transferFrom(alice, bob, zombieId,
      {from: bob});
                  const newOwner = await contractInstance.ownerOf(zombieId);
                  assert.equal(newOwner,bob);
              })
              xit("should approve and then transfer a zombie when the owner
      calls transferForm", async () => {
                  // TODO: Test the two-step scenario.  The owner calls
      transferFrom
               })
          })
      })
---

ç”¨ `approve` åé¢è·Ÿç€ `transferFrom` çš„æ–¹å¼æ¥è½¬ç§»ä»£å¸å¯æ²¡é‚£ä¹ˆç®€å•ï¼Œä¸è¿‡åˆ«æ‹…å¿ƒï¼Œ
æˆ‘ä¼šå¸®ä½ çš„ã€‚

ç®€è€Œè¨€ä¹‹ï¼Œæˆ‘ä»¬å¾—æµ‹è¯•ä¸¤ä¸ªä¸åŒçš„åœºæ™¯ï¼š

- Alice æ‰¹å‡† Bob æ‹¿èµ° ERC721 ä»£å¸ã€‚ç„¶åï¼ŒBobï¼ˆ**æ‰¹å‡†çš„åœ°å€**ï¼‰è°ƒç”¨
  `transferFrom`ã€‚

- Alice æ‰¹å‡† Bob æ‹¿èµ° ERC721 ä»£å¸ã€‚æ¥ä¸‹æ¥ï¼ŒAlice è½¬ç§» ERC721 ä»£å¸ã€‚

è¿™ä¸¤ç§åœºæ™¯çš„åŒºåˆ«åœ¨äº _**è°**_ æ¥è°ƒç”¨å®é™…çš„è½¬ç§»ï¼Œæ˜¯ Alice è¿˜æ˜¯ Bobã€‚

è¿™æ ·è§£é‡Šå°±è¿˜è›®ç®€å•çš„ï¼Œå¯¹å§ï¼Ÿ

æ¥çœ‹ä¸‹ç¬¬ä¸€ä¸ªåœºæ™¯ã€‚

## Bob è°ƒç”¨ transferFrom

è¯¥åœºæ™¯æ­¥éª¤å¦‚ä¸‹:

- Alice åˆ›å»ºä¸€ä¸ªæ–°åƒµå°¸ï¼Œç„¶åè°ƒç”¨ `approve`ã€‚
- æ¥ä¸‹æ¥ï¼ŒBob è¿è¡Œ `transferFrom`ï¼Œè¿™ä¼šè®©ä»–æˆä¸ºè¯¥ EC721 ä»£å¸çš„ä¸»äººã€‚
- æœ€åï¼Œæˆ‘ä»¬å¾—ä»¥ `newOwner` å’Œ `bob` ä½œä¸ºå‚æ•°è°ƒç”¨ `assert.equal`ã€‚

# å®æˆ˜æ¼”ä¹

1. æµ‹è¯•å‰ä¸¤è¡Œä»£ç ä¸ä¹‹å‰æµ‹è¯•ç±»ä¼¼ã€‚æˆ‘ä»¬å·²ç»å¸®ä½ æŠŠå®ƒä»¬å¤åˆ¶ç²˜è´´å¥½äº†ã€‚

2. æ¥ä¸‹æ¥ï¼Œä¸ºäº†æ‰¹å‡† Bob æ‹¿èµ°è¯¥ ERC721 ä»£å¸ï¼Œè°ƒç”¨ `approve()`ã€‚è¯¥å‡½æ•°ä»¥ `bob` å’Œ
   `zombieId` ä¸ºå‚æ•°ã€‚å¦å¤–ï¼Œç¡®ä¿ Alice è°ƒç”¨è¯¥æ–¹æ³•ï¼ˆæ¯•ç«Ÿè¦è½¬ç§»å¯æ˜¯å¥¹çš„ ERC721 ä»£
   å¸ï¼‰ã€‚

3. æœ€åä¸‰è¡Œä»£ç ä¸ä¹‹å‰çš„æµ‹è¯•**éå¸¸ç›¸ä¼¼**ã€‚æˆ‘ä»¬å†ä¸€æ¬¡å¸®ä½ æŠŠå®ƒä»¬å¤åˆ¶ç²˜è´´å¥½äº†ã€‚æ¥æ›´
   æ–°ä¸‹ `transferFrom()` å‡½æ•°è°ƒç”¨ï¼Œä»¥ä¾¿å‘é€æ–¹æ˜¯ Bobã€‚

4. æœ€åï¼Œâ€œä¸è·³è¿‡â€è¿™ä¸ªåœºæ™¯å¹¶â€œè·³è¿‡â€æœ€åä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œå³æˆ‘ä»¬ä»éœ€è¦ç¼–å†™çš„æµ‹è¯•ç”¨ä¾‹ã€‚

å¯ä»¥è¿è¡Œ `truffle test` äº†ï¼Œçœ‹çœ‹æˆ‘ä»¬çš„æµ‹è¯•æ˜¯å¦èƒ½é€šè¿‡:

```bash
Contract: CryptoZombies
    âœ“ should be able to create a new zombie (218ms)
    âœ“ should not allow two zombies (175ms)
    with the single-step transfer scenario
      âœ“ should transfer a zombie (334ms)
    with the two-step transfer scenario
      âœ“ should approve and then transfer a zombie when the owner calls transferForm (360ms)
      - should approve and then transfer a zombie when the approved address calls transferForm


  4 passing (2s)
  1 pending
```

å¾ˆæ£’ï¼ç»§ç»­ä¸‹ä¸€ä¸ªæµ‹è¯•å§ã€‚
