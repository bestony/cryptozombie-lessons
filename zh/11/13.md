---
title: ç”¨ Chai è¿›è¡Œè¯­ä¹‰æ›´ä¸°å¯Œçš„æ–­è¨€
actions: ["checkAnswer", "hints"]
requireLogin: true
material:
  editor:
    language: javascript
    startingCode:
      "test/CryptoZombies.js": |
        const CryptoZombies = artifacts.require("CryptoZombies");
        const utils = require("./helpers/utils");
        const time = require("./helpers/time");
        //TODO: import expect into our project
        const zombieNames = ["Zombie 1", "Zombie 2"];
        contract("CryptoZombies", (accounts) => {
            let [alice, bob] = accounts;
            let contractInstance;
            beforeEach(async () => {
                contractInstance = await CryptoZombies.new();
            });
            it("should be able to create a new zombie", async () => {
                const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                //TODO: replace with expect
                assert.equal(result.receipt.status, true);
                assert.equal(result.logs[0].args.name,zombieNames[0]);
            })
            it("should not allow two zombies", async () => {
                await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                await utils.shouldThrow(contractInstance.createRandomZombie(zombieNames[1], {from: alice}));
            })
            context("with the single-step transfer scenario", async () => {
                it("should transfer a zombie", async () => {
                    const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                    const zombieId = result.logs[0].args.zombieId.toNumber();
                    await contractInstance.transferFrom(alice, bob, zombieId, {from: alice});
                    const newOwner = await contractInstance.ownerOf(zombieId);
                    //TODO: replace with expect
                    assert.equal(newOwner, bob);
                })
            })
            context("with the two-step transfer scenario", async () => {
                it("should approve and then transfer a zombie when the approved address calls transferForm", async () => {
                    const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                    const zombieId = result.logs[0].args.zombieId.toNumber();
                    await contractInstance.approve(bob, zombieId, {from: alice});
                    await contractInstance.transferFrom(alice, bob, zombieId, {from: bob});
                    const newOwner = await contractInstance.ownerOf(zombieId);
                    //TODO: replace with expect
                    assert.equal(newOwner,bob);
                })
                it("should approve and then transfer a zombie when the owner calls transferForm", async () => {
                    const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                    const zombieId = result.logs[0].args.zombieId.toNumber();
                    await contractInstance.approve(bob, zombieId, {from: alice});
                    await contractInstance.transferFrom(alice, bob, zombieId, {from: alice});
                    const newOwner = await contractInstance.ownerOf(zombieId);
                    //TODO: replace with expect
                    assert.equal(newOwner,bob);
                 })
            })
            it("zombies should be able to attack another zombie", async () => {
                let result;
                result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                const firstZombieId = result.logs[0].args.zombieId.toNumber();
                result = await contractInstance.createRandomZombie(zombieNames[1], {from: bob});
                const secondZombieId = result.logs[0].args.zombieId.toNumber();
                await time.increase(time.duration.days(1));
                await contractInstance.attack(firstZombieId, secondZombieId, {from: alice});
                //TODO: replace with expect
                assert.equal(result.receipt.status, true);
            })
        })

      "test/helpers/utils.js": |
        async function shouldThrow(promise) {
        try {
            await promise;
            assert(true);
        }
        catch (err) {
            return;
        }
        assert(false, "The contract did not throw.");

        }

        module.exports = {
            shouldThrow,
        };
      "test/helpers/time.js": |
        async function increase(duration) {

            //first, let's increase time
            await web3.currentProvider.sendAsync({
                jsonrpc: "2.0",
                method: "evm_increaseTime",
                params: [duration], // 86400 seconds in a day
                id: new Date().getTime()
            }, () => {});

            //next, let's mine a new block
            web3.currentProvider.send({
                jsonrpc: '2.0',
                method: 'evm_mine',
                params: [],
                id: new Date().getTime()
            })

        }

        const duration = {

            seconds: function (val) {
                return val;
            },
            minutes: function (val) {
                return val * this.seconds(60);
            },
            hours: function (val) {
                return val * this.minutes(60);
            },
            days: function (val) {
                return val * this.hours(24);
            },
        }

        module.exports = {
            increase,
            duration,
        };

    answer: >
      const CryptoZombies = artifacts.require("CryptoZombies");

      const utils = require("./helpers/utils");

      const time = require("./helpers/time");

      var expect = require('chai').expect;

      const zombieNames = ["Zombie 1", "Zombie 2"];

      contract("CryptoZombies", (accounts) => {
          let [alice, bob] = accounts;
          let contractInstance;
          beforeEach(async () => {
              contractInstance = await CryptoZombies.new();
          });
          it("should be able to create a new zombie", async () => {
              const result = await
      contractInstance.createRandomZombie(zombieNames[0], {from: alice});
              expect(result.receipt.status).to.equal(true);
              expect(result.logs[0].args.name).to.equal(zombieNames[0]);
          })
          it("should not allow two zombies", async () => {
              await contractInstance.createRandomZombie(zombieNames[0], {from:
      alice});
              await
      utils.shouldThrow(contractInstance.createRandomZombie(zombieNames[1],
      {from: alice}));
          })
          context("with the single-step transfer scenario", async () => {
              it("should transfer a zombie", async () => {
                  const result = await
      contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                  const zombieId = result.logs[0].args.zombieId.toNumber();
                  await contractInstance.transferFrom(alice, bob, zombieId,
      {from: alice});
                  const newOwner = await contractInstance.ownerOf(zombieId);
                  expect(newOwner).to.equal(bob);
              })
          })
          context("with the two-step transfer scenario", async () => {
              it("should approve and then transfer a zombie when the approved
      address calls transferForm", async () => {
                  const result = await
      contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                  const zombieId = result.logs[0].args.zombieId.toNumber();
                  await contractInstance.approve(bob, zombieId, {from: alice});
                  await contractInstance.transferFrom(alice, bob, zombieId,
      {from: bob});
                  const newOwner = await contractInstance.ownerOf(zombieId);
                  expect(newOwner).to.equal(bob);
              })
              it("should approve and then transfer a zombie when the owner calls
      transferForm", async () => {
                  const result = await
      contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                  const zombieId = result.logs[0].args.zombieId.toNumber();
                  await contractInstance.approve(bob, zombieId, {from: alice});
                  await contractInstance.transferFrom(alice, bob, zombieId,
      {from: alice});
                  const newOwner = await contractInstance.ownerOf(zombieId);
                  expect(newOwner).to.equal(bob);
               })
          })
          it("zombies should be able to attack another zombie", async () => {
              let result;
              result = await contractInstance.createRandomZombie(zombieNames[0],
      {from: alice});
              const firstZombieId = result.logs[0].args.zombieId.toNumber();
              result = await contractInstance.createRandomZombie(zombieNames[1],
      {from: bob});
              const secondZombieId = result.logs[0].args.zombieId.toNumber();
              await time.increase(time.duration.days(1));
              await contractInstance.attack(firstZombieId, secondZombieId,
      {from: alice});
              expect(result.receipt.status).to.equal(true);
          })
      })
---

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬ä¸€ç›´ä½¿ç”¨å†…ç½®çš„`æ–­è¨€`æ¨¡å—æ¥ç¼–å†™æ–­è¨€ã€‚è™½ç„¶è¿˜ä¸é”™ï¼Œä½†æ˜¯è¿™ä¸ª`æ–­è¨€`æ¨¡
å—æœ‰ä¸€ä¸ªå¤§çš„å¼Šç«¯ â€”â€” ä»£ç ä¸æ˜“è¯»ã€‚å¹¸å¥½ï¼Œè¿˜æœ‰å‡ ä¸ªæ›´å¥½çš„æ–­è¨€æ¨¡å—ï¼Œ`Chai` å°±æ˜¯å…¶ä¸­æœ€
å¥½çš„ä¸€ä¸ªã€‚

## Chai æ–­è¨€åº“

`Chai` éå¸¸å¼ºå¤§ï¼Œå¯¹æœ¬è¯¾æ¥è¯´ï¼Œæˆ‘ä»¬åªä¼šç”¨åˆ°ä¸€ç‚¹çš®æ¯›ã€‚å­¦å®Œæœ¬è¯¾åï¼Œä½ ä¹Ÿå¯ä»¥æŸ¥
çœ‹<a href=" https://www.chaijs.com/guide/" target=_blank>ä»–ä»¬çš„æŒ‡å—</a>ï¼Œä»¥è¿›ä¸€
æ­¥æ‹“å±•çŸ¥è¯†ã€‚

æ¥çœ‹çœ‹ `Chai` ä¸­çš„ä¸‰ç§æ–­è¨€æ ·å¼:

- _expect_: è®©ä½ å¯ä»¥é“¾æ¥è‡ªç„¶è¯­è¨€æ–­è¨€ï¼Œå¦‚ä¸‹æ‰€ç¤º:

  ```javascript
  let lessonTitle = "Testing Smart Contracts with Truffle";
  expect(lessonTitle).to.be.a("string");
  ```

- _should_: è®¸ä½¿ç”¨ä¸ `expect` æ¥å£ç±»ä¼¼çš„æ–­è¨€ï¼Œä½†æ˜¯è¯¥é“¾ä»¥ `should` å±æ€§å¼€å§‹ï¼š

  ```javascript
  let lessonTitle = "Testing Smart Contracts with Truffle";
  lessonTitle.should.be.a("string");
  ```

- _assert_: æä¾›ä¸€ä¸ªç±»ä¼¼äº node.js æ‰“åŒ…çš„ç¬¦å·ï¼ŒåŒ…æ‹¬å‡ ä¸ªé¢å¤–çš„æµ‹è¯•ï¼Œä¸”ä¸æµè§ˆå™¨å…¼
  å®¹:

```javascript
let lessonTitle = "Testing Smart Contracts with Truffle";
assert.typeOf(lessonTitle, "string");
```

åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†å‘ä½ å±•ç¤ºå¦‚ä½•ä½¿ç”¨ `expect` æ¥æ”¹è¿›ä½ çš„æ–­è¨€ã€‚

> æ³¨æ„ï¼šæˆ‘ä»¬å‡è®¾ `chai` åŒ…å·²ç»å®‰è£…åˆ°ä½ çš„ç”µè„‘ä¸Šäº†ã€‚å¦‚æœæ²¡æœ‰ï¼Œå¾ˆå®¹æ˜“å°±èƒ½å®‰è£…
> ï¼š`npm -g install chai`

ä¸ºäº†ä½¿ç”¨ `expect` æ ·å¼ï¼Œæˆ‘ä»¬é¦–å…ˆè¦åšçš„æ˜¯å°†å®ƒå¯¼å…¥åˆ°æˆ‘ä»¬çš„é¡¹ç›®ä¸­ï¼Œå¦‚ä¸‹æ‰€ç¤º:

```javascript
var expect = require("chai").expect;
```

## expect().to.equal()

ç°åœ¨æˆ‘ä»¬å·²ç»å°† `expect` å¯¼å…¥åˆ°æˆ‘ä»¬çš„é¡¹ç›®ä¸­ï¼Œæ£€æŸ¥ä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰å¦‚ä¸‹æ‰€ç¤ºï¼š

```javascript
let zombieName = "My Awesome Zombie";
expect(zombieName).to.equal("My Awesome Zombie");
```

è¯ä¸å¤šè¯´ï¼Œæ¥å¥½å¥½åˆ©ç”¨ä¸‹ `Chai` çš„è¶…èƒ½åŠ›å§ï¼

# å®æˆ˜æ¼”ä¹

1.  å°† `expect` ç§»æ¤åˆ°æˆ‘ä»¬çš„é¡¹ç›®ä¸­ã€‚

2.  ç”¨ `zombieName` ç»§ç»­ä¸Šé¢çš„ä¾‹å­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `expect` æ¥ä¸ºä¸€ä¸ªæˆåŠŸçš„äº‹åŠ¡æµ‹è¯•
    ï¼Œå¦‚ä¸‹æ‰€ç¤º:

```javascript
expect(result.receipt.status).to.equal(true);
```

æˆ‘ä»¬å¯ä»¥è¿™æ ·æ¥æŸ¥çœ‹ Alice æ˜¯å¦æœ‰åƒµå°¸ï¼š

```javascript
expect(zombieOwner).to.equal(alice);
```

1.  ç”¨ `expect` æ¥æ›¿æ¢æ‰€æœ‰çš„ `assert.equal`ã€‚ä¸ºäº†ä¾¿äºæŸ¥æ‰¾ï¼Œæˆ‘ä»¬åœ¨ä»£ç ä¸­ç•™ä¸‹äº†ä¸€
    äº›æ³¨é‡Šã€‚
