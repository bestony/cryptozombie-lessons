---
title: ERC721 ä»£å¸è½¬ç§» â€”â€” ä¸¤æ­¥åœºæ™¯ï¼ˆç»­ï¼‰
actions: ["checkAnswer", "hints"]
requireLogin: true
material:
  editor:
    language: javascript
    startingCode:
      "test/CryptoZombies.js": |
        const CryptoZombies = artifacts.require("CryptoZombies");
        const utils = require("./helpers/utils");
        const zombieNames = ["Zombie 1", "Zombie 2"];
        contract("CryptoZombies", (accounts) => {
            let [alice, bob] = accounts;
            let contractInstance;
            beforeEach(async () => {
                contractInstance = await CryptoZombies.new();
            });
            it("should be able to create a new zombie", async () => {
                const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                assert.equal(result.receipt.status, true);
                assert.equal(result.logs[0].args.name,zombieNames[0]);
            })
            it("should not allow two zombies", async () => {
                await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                await utils.shouldThrow(contractInstance.createRandomZombie(zombieNames[1], {from: alice}));
            })
            context("with the single-step transfer scenario", async () => {
                it("should transfer a zombie", async () => {
                    const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                    const zombieId = result.logs[0].args.zombieId.toNumber();
                    await contractInstance.transferFrom(alice, bob, zombieId, {from: alice});
                    const newOwner = await contractInstance.ownerOf(zombieId);
                    assert.equal(newOwner, bob);
                })
            })
            context("with the two-step transfer scenario", async () => {
                it("should approve and then transfer a zombie when the approved address calls transferForm", async () => {
                    const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                    const zombieId = result.logs[0].args.zombieId.toNumber();
                    await contractInstance.approve(bob, zombieId, {from: alice});
                    await contractInstance.transferFrom(alice, bob, zombieId, {from: bob});
                    const newOwner = await contractInstance.ownerOf(zombieId);
                    assert.equal(newOwner,bob);
                })
                xit("should approve and then transfer a zombie when the owner calls transferForm", async () => {
                    // TODO: start
                 })
            })
        })
      "test/helpers/utils.js": |
        async function shouldThrow(promise) {
        try {
            await promise;
            assert(true);
        }
        catch (err) {
            return;
        }
        assert(false, "The contract did not throw.");

        }

        module.exports = {
            shouldThrow,
        };

    answer: >
      const CryptoZombies = artifacts.require("CryptoZombies");

      const utils = require("./helpers/utils");

      const zombieNames = ["Zombie 1", "Zombie 2"];

      contract("CryptoZombies", (accounts) => {
          let [alice, bob] = accounts;
          let contractInstance;
          beforeEach(async () => {
              contractInstance = await CryptoZombies.new();
          });
          it("should be able to create a new zombie", async () => {
              const result = await
      contractInstance.createRandomZombie(zombieNames[0], {from: alice});
              assert.equal(result.receipt.status, true);
              assert.equal(result.logs[0].args.name,zombieNames[0]);
          })
          it("should not allow two zombies", async () => {
              await contractInstance.createRandomZombie(zombieNames[0], {from:
      alice});
              await
      utils.shouldThrow(contractInstance.createRandomZombie(zombieNames[1],
      {from: alice}));
          })
          context("with the single-step transfer scenario", async () => {
              it("should transfer a zombie", async () => {
                  const result = await
      contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                  const zombieId = result.logs[0].args.zombieId.toNumber();
                  await contractInstance.transferFrom(alice, bob, zombieId,
      {from: alice});
                  const newOwner = await contractInstance.ownerOf(zombieId);
                  assert.equal(newOwner, bob);
              })
          })
          context("with the two-step transfer scenario", async () => {
              it("should approve and then transfer a zombie when the approved
      address calls transferForm", async () => {
                  const result = await
      contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                  const zombieId = result.logs[0].args.zombieId.toNumber();
                  await contractInstance.approve(bob, zombieId, {from: alice});
                  await contractInstance.transferFrom(alice, bob, zombieId,
      {from: bob});
                  const newOwner = await contractInstance.ownerOf(zombieId);
                  assert.equal(newOwner,bob);
              })
              it("should approve and then transfer a zombie when the owner calls
      transferForm", async () => {
                  const result = await
      contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                  const zombieId = result.logs[0].args.zombieId.toNumber();
                  await contractInstance.approve(bob, zombieId, {from: alice});
                  await contractInstance.transferFrom(alice, bob, zombieId,
      {from: alice});
                  const newOwner = await contractInstance.ownerOf(zombieId);
                  assert.equal(newOwner,bob);
               })
          })
      })
---

è½¬ç§»æµ‹è¯•åŸºæœ¬å¿«åˆ°å°¾å£°äº†!ç°åœ¨æ¥æµ‹è¯•ä¸‹ Alice è°ƒç”¨ `transferFrom` çš„åœºæ™¯ã€‚

æœ‰ä¸ªå¥½æ¶ˆæ¯è¦å‘Šè¯‰ä½  â€”â€” è¿™ä¸ªæµ‹è¯•è¶…ç®€å•ã€‚ä½ æ‰€è¦åšçš„å°±æ˜¯å¤åˆ¶ç²˜è´´ä¸Šä¸€ç« çš„ä»£ç ï¼Œè®©
**Alice**ï¼ˆè€Œä¸æ˜¯ Bobï¼‰è°ƒç”¨ `transferFrom`:

# å®æˆ˜æ¼”ä¹

1. å¤åˆ¶ç²˜è´´ä¸Šä¸€ä¸ªæµ‹è¯•ä¸­çš„ä»£ç ï¼Œå¹¶è®© Alice è°ƒç”¨ `transferFrom`ã€‚
2. "ä¸è·³è¿‡"å®ƒï¼Œä¸€åˆ‡å°±ç»ªäº†ã€‚

å¦‚æœä½ è¿è¡Œ `truffle test`ï¼Œè¾“å‡ºä¼šæ˜¯è¿™æ ·:

```bash
Contract: CryptoZombies
    âœ“ should be able to create a new zombie (201ms)
    âœ“ should not allow two zombies (486ms)
    âœ“ should return the correct owner (382ms)
    with the single-step transfer scenario
      âœ“ should transfer a zombie (337ms)
    with the two-step transfer scenario
      âœ“ should approve and then transfer a zombie when the approved address calls transferForm (266ms)
  5 passing (3s)
```

æƒ³ä¸å‡ºè¿˜æœ‰ä»€ä¹ˆå…¶ä»–ä¸è½¬ç§»æœ‰å…³çš„æµ‹è¯•äº†ï¼Œæ‰€ä»¥æš‚æ—¶å°±åˆ°è¿™é‡Œç»“æŸå§ã€‚
